<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>حارس الرياضيات</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: 'Cairo', sans-serif;
            color: white;
            background-color: #1a1a1a;
        }
        #game-container {
            width: 100%;
            height: 100%;
            margin: 0 auto;
            position: relative;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2vw;
            box-sizing: border-box;
            flex-wrap: wrap;
        }
        .hud-box {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 1vh 2.5vw;
            border-radius: 15px;
            border: 2px solid #FFD700;
            font-size: clamp(0.7em, 1.8vw, 1.3em); /* Reduced font size */
            font-weight: bold;
            margin: 5px;
            flex-shrink: 1;
        }
        @keyframes score-pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.4); color: #4CAF50; }
            100% { transform: scale(1); }
        }
        .score-updated {
            display: inline-block;
            animation: score-pop 0.5s ease-in-out;
        }
        .game-message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(2.5em, 8vw, 6em); /* Reduced font size */
            font-weight: bold;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.6);
            z-index: 200;
            display: none;
            pointer-events: none;
        }
        #goalMessage { color: #f44336; } /* Changed to red for goal against player */
        #saveMessage { color: #4CAF50; } /* Changed to green for a good save */
        #mathContainer {
            position: absolute;
            bottom: 2vh;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5vh;
            z-index: 100;
        }
        #question {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 1.5vh 4vw;
            border-radius: 15px;
            font-size: clamp(1.5em, 3.5vw, 2.8em); /* Increased font size */
            font-weight: bold;
            border: 2px solid #fff;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #question .abs-bars {
            color: #FFD700;
            font-weight: bold;
            margin: 0 5px;
        }
        #optionsContainer {
            display: flex;
            gap: 1vw;
            justify-content: center;
            flex-wrap: wrap;
        }
        .option-button {
            background-color: #2196F3;
            border: 2px solid #fff;
            color: white;
            padding: 1.5vh 4vw;
            text-align: center;
            font-size: clamp(1em, 3vw, 2em); /* Increased font size */
            margin: 0.5vh 1vw;
            cursor: pointer;
            border-radius: 12px;
            font-family: 'Cairo', sans-serif;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: background-color 0.3s, transform 0.2s;
        }
        .option-button:hover:not(:disabled) { background-color: #1976D2; transform: scale(1.05); }
        .option-button:disabled { background-color: #9E9E9E; cursor: not-allowed; opacity: 0.6; }
        .correct-answer {
            background-color: #4CAF50 !important;
            border-color: #fff !important;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 300;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2vw;
            box-sizing: border-box;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
        }
        .overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #finalScoreScreen.visible {
            overflow-y: auto;
            justify-content: flex-start;
            padding-top: 5vh;
            padding-bottom: 5vh;
        }
        .overlay h2 { font-size: clamp(1.5em, 4vw, 2.2em); margin-bottom: 2vh; color: #FFD700; } /* Reduced font size */
        .overlay p { font-size: clamp(0.7em, 2vw, 1em); max-width: 90%; line-height: 1.6; } /* Reduced font size */
        .overlay .start-button {
            margin-top: 3vh;
            padding: 1.5vh 6vw;
            font-size: clamp(1em, 3.5vw, 1.8em); /* Reduced font size */
            background-color: #4CAF50;
        }
        .stage-transition h2 {
            transform: scale(0.5);
            opacity: 0;
            animation: pop-in 1s forwards;
        }
        @keyframes pop-in {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        #solutionScreen {
            justify-content: flex-start;
            padding-top: 2vh; /* Raised the entire container */
        }
        #solutionContainer {
            position: relative; /* Add this for positioning context */
            background-color: rgba(40, 40, 40, 0.9);
            padding: 2vh;
            padding-top: 3vh; /* Add a bit more top padding for the content */
            border-radius: 20px;
            border: 2px solid #FFD700;
            width: 90%;
            max-width: 900px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #solutionContainer h2 {
            position: absolute;
            top: 0;
            right: 40px; /* Position from the right */
            transform: translateY(-50%); /* Center on the border */
            background-color: #1a1a1a; /* Match body background */
            padding: 0 15px;
            font-size: clamp(1.3em, 3.5vw, 2em); 
            margin: 0; /* Reset margin */
        }
        #solutionQuestion {
            font-size: clamp(1em, 3vw, 1.6em); /* Reduced font size */
            margin-bottom: 2vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #solutionSteps {
            display: flex;
            justify-content: space-around;
            width: 100%;
            gap: 20px;
            margin-bottom: 2vh;
        }
        .solution-case {
            flex-basis: 48%;
            display: flex;
            flex-direction: column;
            border: 1px solid #555;
            padding: 10px;
            border-radius: 10px;
        }
        .solution-case h3 {
            text-align: center;
            color: #FFD700;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: clamp(0.9em, 2.5vw, 1.3em); /* Reduced font size */
        }
        .solution-step {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            margin-bottom: 1vh;
            width: 100%;
        }
        .solution-eq {
            font-size: clamp(0.8em, 2.2vw, 1.2em); /* Reduced font size */
            font-weight: bold;
            text-align: right;
            width: 100%;
             display: flex;
            align-items: center;
            justify-content: flex-end;
        }
        .solution-comment {
            font-size: clamp(0.6em, 1.8vw, 0.9em); /* Reduced font size */
            color: #ccc;
            text-align: right;
            width: 100%;
        }
        .solution-final-step {
            font-size: clamp(0.9em, 2.5vw, 1.4em); /* Reduced font size */
            font-weight: bold;
            margin-top: 1vh;
        }
        .highlight-math {
            color: #4CAF50;
            font-weight: bold;
        }
        #knowWhyButton {
            position: absolute;
            bottom: 3vh;
            right: 3vh;
            font-size: clamp(0.9em, 2.5vw, 1.3em); /* Reduced font size */
            background-color: #ff9800;
            visibility: hidden;
            z-index: 101;
        }
        #timerDisplay {
            transition: color 0.5s, transform 0.2s;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        #timerDisplay.warning {
            color: #f44336;
            animation: shake 0.5s infinite;
        }
        @keyframes screen-shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .screen-shake {
            animation: screen-shake 0.5s;
        }
        .fraction {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            vertical-align: middle;
            margin: 0 0.4em;
            font-size: 1em;
        }
        .numerator {
            padding: 0 0.4em;
        }
        .denominator {
            border-top: 2px solid white;
            padding: 0 0.4em;
        }
        /* Styles for Leaderboard */
        #finalScoreScreen .text-gray-700 { color: #E5E7EB; }
        #finalScoreScreen .text-blue-600 { color: #3B82F6; }
        #finalScoreScreen .text-gray-800 { color: #F9FAFB; }
        #finalScoreScreen .bg-white { background-color: rgba(31, 41, 55, 0.5); }
        #finalScoreScreen .bg-gray-100 { background-color: rgba(55, 65, 81, 0.5); }
        #finalScoreScreen .bg-blue-100 { background-color: rgba(59, 130, 246, 0.3); }
        #finalScoreScreen tbody.text-gray-700 { color: #D1D5DB; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
</head>
<body>
    <div id="game-container">
        <div id="info" style="visibility: hidden;">
            <div id="scoreDisplay" class="hud-box">النتيجة: <span id="scoreValue">٠</span></div>
            <div id="stageInfo" class="hud-box">المرحلة ١ - السؤال ١ / ٥</div>
            <div class="hud-box">الوقت الإجمالي: <span id="totalTimeValue">٠</span></div>
            <div id="timerDisplay" class="hud-box">الوقت: <span id="timerValue">٤٥</span></div>
        </div>

        <div id="goalMessage" class="game-message">هدف</div>
        <div id="saveMessage" class="game-message">تصدي</div>
        <div id="mathContainer" style="visibility: hidden;">
            <div id="question"></div>
            <div id="optionsContainer"></div>
        </div>
        <button id="knowWhyButton" class="option-button">اعرف لماذا؟</button>

        <div id="welcomeScreen" class="overlay visible">
            <h2>أهلاً بك في لعبة حارس الرياضيات</h2>
            <p>تصميم وبرمجة /  أ. عبدالعزيز خالد العبلان</p>
            <p style="color: #FFD700; font-size: 1.8em; margin: 20px 0;">أنت الآن حارس المرمى! أجب بشكل صحيح للتصدي للكرة وكسب نقطة.</p>
            <p><strong>طريقة اللعب:</strong> إذا كانت إجابتك صحيحة، ستتصدى للكرة. إذا كانت خاطئة، سيدخل هدف في مرماك!</p>
            <button id="startButton" class="option-button start-button">ابدأ اللعب</button>
        </div>

        <div id="stageTransitionScreen" class="overlay stage-transition">
            <h2 id="stageTransitionText"></h2>
        </div>

        <div id="finalScoreScreen" class="overlay">
             <div class="w-full max-w-2xl">
                <h2>انتهت اللعبة!</h2>
                <p id="feedbackText" style="font-size: 1.8em;"></p>
                
                <!-- 1. لعرض نتيجة الطالب الحالية -->
                <div id="final-result-display" class="text-center text-xl mt-4"></div>

                <!-- 2. لعرض أيقونة التحميل -->
                <div id="leaderboard-loader" style="display: none;" class="text-center mt-6">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900 mx-auto"></div>
                    <p>جاري تحميل سجل الأبطال...</p>
                </div>

                <!-- 3. لعرض جدول سجل الأبطال -->
                <div id="leaderboard-container" class="mt-4"></div>

                <!-- 4. زر لإنهاء اللعبة والعودة للمنصة (جديد) -->
                <div id="finish-game-wrapper" class="text-center mt-6" style="display: none;">
                    <button id="finish-game-btn" class="px-6 py-3 bg-red-600 text-white font-bold rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-400 focus:ring-opacity-75 transition-transform transform hover:scale-105">
                        إنهاء والعودة للمنصة
                    </button>
                </div>

                <button id="playAgainButton" class="option-button start-button mt-4">العب مرة أخرى</button>
            </div>
        </div>

        <div id="solutionScreen" class="overlay">
            <div id="solutionContainer">
                <h2>طريقة الحل</h2>
                <p id="solutionQuestion"></p>
                <div id="solutionSteps"></div>
                <div id="finalSolutionStep" class="solution-final-step"></div>
                <button id="closeSolutionButton" class="option-button">إغلاق</button>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let ball, ballVelocity, isBallShot = false, goalScored = false;
        let keeperGroup, keeperTarget, isKeeperReacting = false, keeperSaved = false;
        let leftArm, rightArm, initialLeftArmRot, initialRightArmRot;
        let net, originalNetVertices;
        let collisionAura, auraBoundingBox;
        let leftPost, rightPost, crossbar;
        let attackers = [];
        let kicker;
        let flags = [];
        
        let goalMessageElement, saveMessageElement;
        let questionElement, optionsContainer, stageInfoElement, scoreDisplayElement, scoreValueElement;
        let welcomeScreen, startButton, stageTransitionScreen, stageTransitionText, finalScoreScreen, finalScoreText, playAgainButton, feedbackText;
        let infoContainer, mathContainer, knowWhyButton;
        let solutionScreen, solutionContainer, solutionQuestion, solutionSteps, closeSolutionButton, finalSolutionStep;
        let timerDisplay, timerValueElement, totalTimeValueElement;
        
        let currentStage = 1;
        let questionIndex = 0;
        const problemsPerStage = [5, 5];
        let currentProblem = {};
        let shotTypeGlobal = '';
        let hasHitNet = false;
        let score = 0;
        let timerInterval, totalTimeInterval;
        let timeLeft = 45;
        let totalGameTime = 0;
        const TIME_PER_QUESTION = 45;
        let resetTimeoutId = null;
        let isResetting = false;
        let confettiGroup, confettiParticles = [];
        let stage1ProblemTypes = [];
        let stage2ProblemTypes = [];

        let initialKeeperPosition = new THREE.Vector3();

        const ballRadius = 0.15;
        const gravity = new THREE.Vector3(0, -0.015, 0);
        const goalLineZ = 0.5;
        const goalWidth = 7.32;
        const goalHeight = 2.44;
        const netDepth = 2;
        const postRadius = 0.08;
        
        const crowdCheer = new Tone.NoiseSynth({
            noise: { type: 'pink' },
            envelope: { attack: 0.2, decay: 1.5, sustain: 0, release: 1 }
        }).toDestination();
        crowdCheer.volume.value = -12;

        const netSound = new Tone.NoiseSynth({
            noise: { type: 'white' },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0 }
        }).toDestination();
        netSound.volume.value = -6;

        const saveSound = new Tone.MembraneSynth({
            pitchDecay: 0.08,
            octaves: 4,
            envelope: { attack: 0.001, decay: 0.3, sustain: 0.01, release: 0.5 }
        }).toDestination();
        saveSound.volume.value = -6;

        const whistle = new Tone.Synth({
            oscillator: { type: 'triangle' },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 }
        }).toDestination();
        const vibrato = new Tone.LFO("20hz", 400, 450).start();
        vibrato.connect(whistle.frequency);

        const excellentFeedback = [
            "رائع! أنت نجم الرياضيات، فهمك للقيمة المطلقة ممتاز.",
            "عمل مذهل! لقد أتقنت المهارة، استمر في هذا التفوق.",
            "أحسنت! نتيجتك تدل على تركيز وفهم عميق للدرس."
        ];
        const goodFeedback = [
            "جيد جدًا! أنت على الطريق الصحيح لفهم القيمة المطلقة بشكل كامل.",
            "عمل رائع! بعض الأخطاء البسيطة لا تقلل من مجهودك. حاول مرة أخرى للوصول للعلامة الكاملة.",
            "أحسنت! لقد فهمت الفكرة الأساسية، والقليل من المراجعة سيجعلك محترفًا."
        ];
        const needsImprovementFeedback = [
            "بداية جيدة! كل خطأ هو فرصة للتعلم. استخدم زر 'اعرف لماذا؟' لمراجعة الحلول.",
            "لا تستسلم! القيمة المطلقة تحتاج للقليل من التدريب. أنا واثق أنك ستتقنها في المرة القادمة.",
            "مجهود طيب! حاول التركيز على ترتيب العمليات، وستجد أن المسائل أصبحت أسهل."
        ];
        const lowFeedback = [
            "للاسف مستواك ضعيف ! ومع ذلك كل خطأ هو فرصة للتعلم. استخدم زر 'اعرف لماذا؟' لمراجعة الحلول.",
            "لا تستسلم! القيمة المطلقة تحتاج للكثير من التدريب. أنا واثق أنك ستتقنها في المرة القادمة.",
            "حاول مرة اخرى ! حاول التركيز على ترتيب العمليات، وستجد أن المسائل أصبحت أسهل."
        ];


        function init() {
            goalMessageElement = document.getElementById('goalMessage');
            saveMessageElement = document.getElementById('saveMessage');
            questionElement = document.getElementById('question');
            optionsContainer = document.getElementById('optionsContainer');
            stageInfoElement = document.getElementById('stageInfo');
            scoreDisplayElement = document.getElementById('scoreDisplay');
            scoreValueElement = document.getElementById('scoreValue');
            welcomeScreen = document.getElementById('welcomeScreen');
            startButton = document.getElementById('startButton');
            stageTransitionScreen = document.getElementById('stageTransitionScreen');
            stageTransitionText = document.getElementById('stageTransitionText');
            finalScoreScreen = document.getElementById('finalScoreScreen');
            playAgainButton = document.getElementById('playAgainButton');
            feedbackText = document.getElementById('feedbackText');
            infoContainer = document.getElementById('info');
            mathContainer = document.getElementById('mathContainer');
            knowWhyButton = document.getElementById('knowWhyButton');
            solutionScreen = document.getElementById('solutionScreen');
            solutionContainer = document.getElementById('solutionContainer');
            solutionQuestion = document.getElementById('solutionQuestion');
            solutionSteps = document.getElementById('solutionSteps');
            closeSolutionButton = document.getElementById('closeSolutionButton');
            finalSolutionStep = document.getElementById('finalSolutionStep');
            timerDisplay = document.getElementById('timerDisplay');
            timerValueElement = document.getElementById('timerValue');
            totalTimeValueElement = document.getElementById('totalTimeValue');
            
            startButton.addEventListener('click', startGame);
            playAgainButton.addEventListener('click', restartGame);
            knowWhyButton.addEventListener('click', showSolution);
            closeSolutionButton.addEventListener('click', closeSolution);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 10, 150); // Increased fog distance

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // --- NEW CAMERA POSITION ---
            camera.position.set(0, 4, -2);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            // --- NEW TARGET POSITION ---
            controls.target.set(0, 1, 7);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            createFieldAndGoal();
            createGoalkeeper();
            createBall();
            createAttackers();
            createStadiumAndCrowd();
            
            confettiGroup = new THREE.Group();
            scene.add(confettiGroup);
            
            window.addEventListener('resize', onWindowResize);
            animate();
        }
        
        function createFieldAndGoal() {
            // Increased ground size to be more like a football pitch
            const groundGeometry = new THREE.PlaneGeometry(100, 200);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // --- Field Markings ---
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
            const points = [];
            const pitchWidth = 68;
            const pitchLength = 105;
            const frontZ = 0;
            const backZ = frontZ + pitchLength;

            // Outer lines
            points.push(new THREE.Vector3(-pitchWidth / 2, 0.01, frontZ));
            points.push(new THREE.Vector3(pitchWidth / 2, 0.01, frontZ));
            points.push(new THREE.Vector3(pitchWidth / 2, 0.01, backZ));
            points.push(new THREE.Vector3(-pitchWidth / 2, 0.01, backZ));
            points.push(new THREE.Vector3(-pitchWidth / 2, 0.01, frontZ));
            
            // Center line
            const centerZ = frontZ + pitchLength / 2;
            points.push(new THREE.Vector3(-pitchWidth / 2, 0.01, centerZ));
            points.push(new THREE.Vector3(pitchWidth / 2, 0.01, centerZ));

            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const fieldLines = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(fieldLines);

            // Center Circle
            const circleRadius = 9.15;
            const circleSegments = 64;
            const circlePoints = [];
            for (let i = 0; i <= circleSegments; i++) {
                const theta = (i / circleSegments) * Math.PI * 2;
                circlePoints.push(new THREE.Vector3(Math.cos(theta) * circleRadius, 0.01, Math.sin(theta) * circleRadius + centerZ));
            }
            const circleGeometry = new THREE.BufferGeometry().setFromPoints(circlePoints);
            const centerCircle = new THREE.Line(circleGeometry, lineMaterial);
            scene.add(centerCircle);

            // Penalty Area (near the player's goal)
            const penaltyAreaWidth = 40.3;
            const penaltyAreaLength = 16.5;
            const penaltyPoints = [];
            penaltyPoints.push(new THREE.Vector3(-penaltyAreaWidth / 2, 0.01, frontZ));
            penaltyPoints.push(new THREE.Vector3(penaltyAreaWidth / 2, 0.01, frontZ));
            penaltyPoints.push(new THREE.Vector3(penaltyAreaWidth / 2, 0.01, frontZ + penaltyAreaLength));
            penaltyPoints.push(new THREE.Vector3(-penaltyAreaWidth / 2, 0.01, frontZ + penaltyAreaLength));
            penaltyPoints.push(new THREE.Vector3(-penaltyAreaWidth / 2, 0.01, frontZ));
            const penaltyGeometry = new THREE.BufferGeometry().setFromPoints(penaltyPoints);
            const penaltyArea = new THREE.Line(penaltyGeometry, lineMaterial);
            scene.add(penaltyArea);

            // --- Main Goal ---
            const goalMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.2, roughness: 0.1 });
            leftPost = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalHeight, 32), goalMaterial);
            leftPost.position.set(-goalWidth / 2, goalHeight / 2, 0);
            leftPost.castShadow = true;
            scene.add(leftPost);
            rightPost = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalHeight, 32), goalMaterial);
            rightPost.position.set(goalWidth / 2, goalHeight / 2, 0);
            rightPost.castShadow = true;
            scene.add(rightPost);
            crossbar = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalWidth, 32), goalMaterial);
            crossbar.position.set(0, goalHeight, 0);
            crossbar.rotation.z = Math.PI / 2;
            crossbar.castShadow = true;
            scene.add(crossbar);

            const netCanvas = document.createElement('canvas');
            netCanvas.width = 64;
            netCanvas.height = 64;
            const netContext = netCanvas.getContext('2d');
            netContext.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            netContext.lineWidth = 5;
            netContext.strokeRect(0, 0, 64, 64);
            const netTexture = new THREE.CanvasTexture(netCanvas);
            netTexture.wrapS = THREE.RepeatWrapping;
            netTexture.wrapT = THREE.RepeatWrapping;
            
            const netMaterial = new THREE.MeshBasicMaterial({
                map: netTexture,
                transparent: true,
                side: THREE.DoubleSide,
                alphaTest: 0.1
            });

            const netGeometry = new THREE.PlaneGeometry(goalWidth, goalHeight, 20, 10);
            originalNetVertices = netGeometry.attributes.position.array.slice();
            net = new THREE.Mesh(netGeometry, netMaterial);
            net.position.set(0, goalHeight / 2, -netDepth);
            netTexture.repeat.set(15, 5);
            scene.add(net);
            
            const topNetGeometry = new THREE.PlaneGeometry(goalWidth, netDepth, 20, 5);
            const topNet = new THREE.Mesh(topNetGeometry, netMaterial.clone());
            topNet.material.map = netTexture.clone();
            topNet.material.map.repeat.set(15, 2);
            topNet.rotation.x = -Math.PI / 2;
            topNet.position.set(0, goalHeight, -netDepth / 2);
            scene.add(topNet);

            const sideNetGeometry = new THREE.PlaneGeometry(netDepth, goalHeight, 5, 10);
            const leftNet = new THREE.Mesh(sideNetGeometry, netMaterial.clone());
            leftNet.material.map = netTexture.clone();
            leftNet.material.map.repeat.set(2, 5);
            leftNet.rotation.y = Math.PI / 2;
            leftNet.position.set(-goalWidth / 2, goalHeight / 2, -netDepth / 2);
            scene.add(leftNet);

            const rightNet = new THREE.Mesh(sideNetGeometry, netMaterial.clone());
            rightNet.material.map = netTexture.clone();
            rightNet.material.map.repeat.set(2, 5);
            rightNet.rotation.y = -Math.PI / 2;
            rightNet.position.set(goalWidth / 2, goalHeight / 2, -netDepth / 2);
            scene.add(rightNet);

            // --- Opponent's Goal ---
            const opponentGoal = new THREE.Group();
            const oppLeftPost = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalHeight, 32), goalMaterial);
            oppLeftPost.position.set(-goalWidth / 2, goalHeight / 2, 0);
            opponentGoal.add(oppLeftPost);
            const oppRightPost = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalHeight, 32), goalMaterial);
            oppRightPost.position.set(goalWidth / 2, goalHeight / 2, 0);
            opponentGoal.add(oppRightPost);
            const oppCrossbar = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalWidth, 32), goalMaterial);
            oppCrossbar.position.set(0, goalHeight, 0);
            oppCrossbar.rotation.z = Math.PI / 2;
            opponentGoal.add(oppCrossbar);
            opponentGoal.position.z = backZ;
            scene.add(opponentGoal);
        }
        
        function createGoalkeeper() {
            keeperGroup = new THREE.Group();
            keeperGroup.position.set(0, 0, goalLineZ);
            initialKeeperPosition.copy(keeperGroup.position);
            keeperTarget = new THREE.Vector3();
            scene.add(keeperGroup);

            const torsoMaterial = new THREE.MeshStandardMaterial({ color: '#ff8c00' });
            const shortsMaterial = new THREE.MeshStandardMaterial({ color: 0x1e1e1e });
            const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xDEB887 });
            const glovesMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });

            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.3), torsoMaterial);
            torso.position.y = 1;
            keeperGroup.add(torso);
            
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), skinMaterial);
            head.position.y = 1.55;
            keeperGroup.add(head);

            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.03, 16, 16), eyeMaterial);
            leftEye.position.set(0.1, 0.05, 0.18);
            head.add(leftEye);
            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.03, 16, 16), eyeMaterial);
            rightEye.position.set(-0.1, 0.05, 0.18);
            head.add(rightEye);

            const hairMaterial = new THREE.MeshStandardMaterial({ color: 0x202020 });
            const hairGeometry = new THREE.SphereGeometry(0.22, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 0;
            hair.rotation.x = -0.1;
            head.add(hair);

            const pelvis = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.3), shortsMaterial);
            pelvis.position.y = 0.55;
            keeperGroup.add(pelvis);
            
            const legAngle = -0.2;
            const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.08, 0.9), shortsMaterial);
            rightLeg.position.set(-0.15, 0.1, 0);
            rightLeg.rotation.z = -legAngle;
            keeperGroup.add(rightLeg);
            
            const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.08, 0.9), shortsMaterial);
            leftLeg.position.set(0.15, 0.1, 0);
            leftLeg.rotation.z = legAngle;
            keeperGroup.add(leftLeg);

            const armLength = 0.6;
            rightArm = new THREE.Object3D();
            rightArm.position.set(-0.25, 0.3, 0);
            torso.add(rightArm);
            const rightArmMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.06, armLength), torsoMaterial);
            rightArmMesh.position.y = -armLength / 2;
            rightArm.add(rightArmMesh);
            
            const rightGlove = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), glovesMaterial);
            rightGlove.position.y = -armLength / 2;
            rightArmMesh.add(rightGlove);

            leftArm = new THREE.Object3D();
            leftArm.position.set(0.25, 0.3, 0);
            torso.add(leftArm);
            const leftArmMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.06, armLength), torsoMaterial);
            leftArmMesh.position.y = -armLength / 2;
            leftArm.add(leftArmMesh);
            
            const leftGlove = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), glovesMaterial);
            leftGlove.position.y = -armLength / 2;
            leftArmMesh.add(leftGlove);

            const armbandMaterial = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
            const armbandGeometry = new THREE.CylinderGeometry(0.085, 0.085, 0.1, 32);
            const armband = new THREE.Mesh(armbandGeometry, armbandMaterial);
            armband.position.y = -0.1;
            leftArmMesh.add(armband);

            const armAngle = 1.2;
            rightArm.rotation.z = -armAngle;
            leftArm.rotation.z = armAngle;

            initialLeftArmRot = leftArm.rotation.clone();
            initialRightArmRot = rightArm.rotation.clone();

            const auraGeometry = new THREE.BoxGeometry(2.5, 2.5, 0.5);
            const auraMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.0 });
            collisionAura = new THREE.Mesh(auraGeometry, auraMaterial);
            collisionAura.position.y = 1; 
            keeperGroup.add(collisionAura);
            auraBoundingBox = new THREE.Box3().setFromObject(collisionAura);
        }

        function createAttackers() {
            const attackerGroup = new THREE.Group();
            scene.add(attackerGroup);

            const numPlayers = 4;
            
            for (let i = 0; i < numPlayers; i++) {
                const player = new THREE.Group();
                const torsoMaterial = new THREE.MeshStandardMaterial({ color: 0x2196F3 }); // Blue shirts
                const shortsMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xDEB887 });

                const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.3), torsoMaterial);
                torso.position.y = 1;
                player.add(torso);
                
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), skinMaterial);
                head.position.y = 1.55;
                player.add(head);

                const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.08, 0.9), shortsMaterial);
                rightLeg.position.set(-0.15, 0.1, 0);
                player.add(rightLeg);
                
                const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.08, 0.9), shortsMaterial);
                leftLeg.position.set(0.15, 0.1, 0);
                player.add(leftLeg);

                const armLength = 0.6;
                const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.06, armLength), torsoMaterial);
                rightArm.position.set(-0.3, 1, 0);
                rightArm.rotation.z = -Math.PI / 4;
                player.add(rightArm);

                const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.06, armLength), torsoMaterial);
                leftArm.position.set(0.3, 1, 0);
                leftArm.rotation.z = Math.PI / 4;
                player.add(leftArm);

                player.castShadow = true;
                attackerGroup.add(player);

                if (i === 0) { // Designate the first player as the kicker
                    kicker = {mesh: player, isKicking: false};
                    kicker.mesh.position.set(0, 0, 7.5); // Positioned right behind the ball
                } else {
                    // Position other players randomly
                    player.position.set(
                        THREE.MathUtils.randFloatSpread(8),
                        0,
                        THREE.MathUtils.randFloat(8, 12)
                    );
                    attackers.push({mesh: player, offset: Math.random() * Math.PI * 2});
                }
            }
        }

        function createStadiumAndCrowd() {
            // --- Stadium Structure ---
            const stadiumHeight = 20;
            const stadiumRadius = 60;
            const stadiumGeometry = new THREE.CylinderGeometry(stadiumRadius, stadiumRadius * 1.2, stadiumHeight, 64, 1, true);
            stadiumGeometry.translate(0, 0, 52.5); // Lowered the stadium
            const stadiumMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xAAAAAA, 
                side: THREE.DoubleSide,
                metalness: 0.2,
                roughness: 0.8
            });
            const stadium = new THREE.Mesh(stadiumGeometry, stadiumMaterial);
            scene.add(stadium);

            // --- Crowd Texture ---
            const crowdCanvas = document.createElement('canvas');
            crowdCanvas.width = 1024;
            crowdCanvas.height = 512;
            const crowdContext = crowdCanvas.getContext('2d');
            crowdContext.fillStyle = '#333333';
            crowdContext.fillRect(0, 0, crowdCanvas.width, crowdCanvas.height);
            const colors = ['#FF4136', '#0074D9', '#2ECC40', '#FFDC00', '#B10DC9', '#FFFFFF'];
            for (let i = 0; i < 20000; i++) {
                crowdContext.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                crowdContext.fillRect(
                    Math.random() * crowdCanvas.width,
                    Math.random() * crowdCanvas.height,
                    2, 2
                );
            }
            const crowdTexture = new THREE.CanvasTexture(crowdCanvas);
            crowdTexture.wrapS = THREE.RepeatWrapping;
            crowdTexture.wrapT = THREE.RepeatWrapping;
            crowdTexture.repeat.set(8, 4);

            const crowdMaterial = new THREE.MeshBasicMaterial({ map: crowdTexture, side: THREE.BackSide });
            const crowdStands = new THREE.Mesh(stadiumGeometry, crowdMaterial);
            scene.add(crowdStands);

            // --- Flags ---
            const flagCount = 20;
            for (let i = 0; i < flagCount; i++) {
                const flagPole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0xCCCCCC })
                );
                const flagCloth = new THREE.Mesh(
                    new THREE.PlaneGeometry(3, 2, 15, 10),
                    new THREE.MeshBasicMaterial({ color: new THREE.Color(Math.random(), Math.random(), Math.random()), side: THREE.DoubleSide })
                );

                flagCloth.position.y = 2.5;
                flagCloth.position.x = 1.5;
                flagPole.add(flagCloth);

                const angle = (i / flagCount) * Math.PI * 2;
                flagPole.position.set(
                    Math.cos(angle) * (stadiumRadius * 1.2),
                    stadiumHeight / 2, // Lowered the flags
                    Math.sin(angle) * (stadiumRadius * 1.2) + 52.5
                );
                flagPole.lookAt(0, stadiumHeight / 2, 52.5);
                
                scene.add(flagPole);
                flags.push(flagCloth);
            }
        }


        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            context.fillStyle = '#FFFFFF';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#000000';
            function drawHexagon(x, y, size) {
                context.beginPath();
                for (let i = 0; i < 6; i++) {
                    context.lineTo(x + size * Math.cos(i * Math.PI / 3), y + size * Math.sin(i * Math.PI / 3));
                }
                context.closePath();
                context.fill();
            }
            drawHexagon(64, 40, 22);
            drawHexagon(192, 40, 22);
            drawHexagon(128, 95, 22);
            drawHexagon(250, 95, 22);
            drawHexagon(6, 95, 22);
            const ballTexture = new THREE.CanvasTexture(canvas);
            const ballMaterial = new THREE.MeshStandardMaterial({ map: ballTexture, metalness: 0.1, roughness: 0.5 });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.castShadow = true;
            ball.receiveShadow = true;
            ballVelocity = new THREE.Vector3();
            resetGame(true);
            scene.add(ball);
        }

        async function startGame() {
            await Tone.start();
            welcomeScreen.classList.remove('visible');
            showStageIntro(1);
        }

        function restartGame() {
            finalScoreScreen.classList.remove('visible');
            showStageIntro(1);
        }

        function showStageIntro(stage) {
            stageTransitionText.innerText = `المرحلة ${toArabicNumerals(stage)}`;
            stageTransitionScreen.classList.add('visible');
            setTimeout(() => {
                stageTransitionScreen.classList.remove('visible');
                infoContainer.style.visibility = 'visible';
                mathContainer.style.visibility = 'visible';
                startStage(stage);
            }, 2500);
        }

        function startStage(stage) {
            currentStage = stage;
            questionIndex = 0;
            if (stage === 1) {
                score = 0;
                totalGameTime = 0;
                clearInterval(totalTimeInterval);
                totalTimeInterval = setInterval(() => {
                    totalGameTime++;
                    totalTimeValueElement.innerText = toArabicNumerals(totalGameTime);
                }, 1000);
                // Guarantees 4 problems with 2 solutions and 1 with no solution
                stage1ProblemTypes = ['eq_x_minus_b', 'eq_x_minus_b', 'eq_ax', 'eq_ax', 'eq_x_is_neg'];
                stage1ProblemTypes.sort(() => Math.random() - 0.5);
            } else if (stage === 2) {
                // Guarantees 5 problems with 2 solutions
                stage2ProblemTypes = ['eq_ax_minus_b', 'eq_ax_minus_b', 'eq_x_div_a', 'eq_x_div_a', 'eq_plus_d'];
                stage2ProblemTypes.sort(() => Math.random() - 0.5);
            }
            updateScoreDisplay(true);
            displayNewQuestion();
        }

        function toArabicNumerals(num) {
            const arabicNumerals = ['٠', '١', '٢', '٣', '٤', '٥', '٦', '٧', '٨', '٩'];
            const sign = num < 0 ? '−' : '';
            const numStr = String(Math.abs(num));
            return sign + numStr.replace(/[0-9]/g, d => arabicNumerals[parseInt(d)]);
        }

        function formatAnswer(answer) {
            if (typeof answer === 'string') {
                return answer;
            }
            if (Array.isArray(answer) && answer.length > 0) {
                const sorted = [...answer].sort((a, b) => b - a); // Create a sorted copy
                return `{ ${sorted.map(toArabicNumerals).join(' , ')} }`;
            }
            return '';
        }

        function generateProblem(stage) {
            let html, answer, steps, rhs;
            let problemType;

            if (stage === 1) {
                problemType = stage1ProblemTypes[questionIndex];
            } else {
                problemType = stage2ProblemTypes[questionIndex];
            }

            switch (problemType) {
                case 'eq_x_minus_b': { // | س - b | = c
                    const b = Math.floor(Math.random() * 8) + 1;
                    const c = Math.floor(Math.random() * 8) + 1;
                    const sol1 = c + b;
                    const sol2 = -c + b;
                    html = `<span class="abs-bars">|</span> س - ${toArabicNumerals(b)} <span class="abs-bars">|</span>`;
                    rhs = `= ${toArabicNumerals(c)}`;
                    answer = [sol1, sol2];
                    steps = {
                        case1: [
                            { eq: `س - ${toArabicNumerals(b)} = ${toArabicNumerals(c)}`, comment: "الحالة الأولى (الموجبة)" },
                            { eq: `س = ${toArabicNumerals(c)} + ${toArabicNumerals(b)} &nbsp;&nbsp;&lArr;&nbsp;&nbsp;  س = ${toArabicNumerals(sol1)}`, comment: "حل الحالة الأولى" }
                        ],
                        case2: [
                            { eq: `س - ${toArabicNumerals(b)} = ${toArabicNumerals(-c)}`, comment: "الحالة الثانية (السالبة)" },
                            { eq: `س = ${toArabicNumerals(-c)} + ${toArabicNumerals(b)} &nbsp;&nbsp;&lArr;&nbsp;&nbsp;  س = ${toArabicNumerals(sol2)}`, comment: "حل الحالة الثانية" }
                        ],
                        final: { eq: `مجموعة الحل هي ${formatAnswer(answer)}`, comment: "النتيجة النهائية" }
                    };
                    break;
                }
                case 'eq_x_is_neg': { // | س - b | = -c
                    const b = Math.floor(Math.random() * 10) + 1;
                    const c = Math.floor(Math.random() * 10) + 1;
                    html = `<span class="abs-bars">|</span> س - ${toArabicNumerals(b)} <span class="abs-bars">|</span>`;
                    rhs = `= ${toArabicNumerals(-c)}`;
                    answer = "لا يوجد حل";
                    steps = [
                        { eq: `| س - ${toArabicNumerals(b)} | = ${toArabicNumerals(-c)}`, comment: "المسألة الأصلية" },
                        { eq: `مستحيل`, comment: "القيمة المطلقة لا يمكن أن تكون سالبة" },
                        { eq: `مجموعة الحل هي &empty;`, comment: "لا يوجد حل حقيقي للمعادلة" }
                    ];
                    break;
                }
                case 'eq_ax': { // | aس | = c
                    const a = Math.floor(Math.random() * 4) + 2; // 2 to 5
                    const sol1 = Math.floor(Math.random() * 5) + 1; // 1 to 5
                    const c = a * sol1;
                    const sol2 = -sol1;
                    html = `<span class="abs-bars">|</span> ${toArabicNumerals(a)}س <span class="abs-bars">|</span>`;
                    rhs = `= ${toArabicNumerals(c)}`;
                    answer = [sol1, sol2];
                    steps = {
                        case1: [
                            { eq: `${toArabicNumerals(a)}س = ${toArabicNumerals(c)}`, comment: "الحالة الأولى" },
                            { eq: `س = ${toArabicNumerals(sol1)}`, comment: "بقسمة الطرفين على " + toArabicNumerals(a) }
                        ],
                        case2: [
                            { eq: `${toArabicNumerals(a)}س = ${toArabicNumerals(-c)}`, comment: "الحالة الثانية" },
                            { eq: `س = ${toArabicNumerals(sol2)}`, comment: "بقسمة الطرفين على " + toArabicNumerals(a) }
                        ],
                        final: { eq: `مجموعة الحل هي ${formatAnswer(answer)}`, comment: "النتيجة النهائية" }
                    };
                    break;
                }
                case 'eq_ax_minus_b': { // |2س - b| = c
                    const a = 2;
                    const b = Math.floor(Math.random() * 5) * 2 + 1; // Random odd number 1,3,5,7,9
                    const c = Math.floor(Math.random() * 5) * 2 + 1; // Random odd number
                    const sol1 = (c + b) / a;
                    const sol2 = (-c + b) / a;
                    html = `<span class="abs-bars">|</span> ${toArabicNumerals(a)}س - ${toArabicNumerals(b)} <span class="abs-bars">|</span>`;
                    rhs = `= ${toArabicNumerals(c)}`;
                    answer = [sol1, sol2];
                    steps = {
                        case1: [
                            { eq: `${toArabicNumerals(a)}س - ${toArabicNumerals(b)} = ${toArabicNumerals(c)}`, comment: "الحالة الأولى" },
                            { eq: `${toArabicNumerals(a)}س = ${toArabicNumerals(c+b)} &nbsp;&nbsp;&lArr;&nbsp;&nbsp;  س = ${toArabicNumerals(sol1)}`, comment: "حل الحالة الأولى" }
                        ],
                        case2: [
                            { eq: `${toArabicNumerals(a)}س - ${toArabicNumerals(b)} = ${toArabicNumerals(-c)}`, comment: "الحالة الثانية" },
                            { eq: `${toArabicNumerals(a)}س = ${toArabicNumerals(-c+b)} &nbsp;&nbsp;&lArr;&nbsp;&nbsp;  س = ${toArabicNumerals(sol2)}`, comment: "حل الحالة الثانية" }
                        ],
                        final: { eq: `مجموعة الحل هي ${formatAnswer(answer)}`, comment: "النتيجة النهائية" }
                    };
                    break;
                }
                case 'eq_x_div_a': { // | س/a + b | = c
                    const a = 2;
                    const b = Math.floor(Math.random() * 5) + 1; // 1 to 5
                    const c = Math.floor(Math.random() * 5) + b + 1; // c > b
                    const sol1 = (c - b) * a;
                    const sol2 = (-c - b) * a;
                    html = `<span class="abs-bars">|</span>
                            <div class='fraction'>
                                <span class='numerator'>س</span>
                                <span class='denominator'>${toArabicNumerals(a)}</span>
                            </div> + ${toArabicNumerals(b)}
                            <span class="abs-bars">|</span>`;
                    rhs = `= ${toArabicNumerals(c)}`;
                    answer = [sol1, sol2];
                    steps = {
                        case1: [
                            { eq: `<div class='fraction'><span class='numerator'>س</span><span class='denominator'>${toArabicNumerals(a)}</span></div> + ${toArabicNumerals(b)} = ${toArabicNumerals(c)}`, comment: "الحالة الأولى" },
                            { eq: `<div class='fraction'><span class='numerator'>س</span><span class='denominator'>${toArabicNumerals(a)}</span></div> = ${toArabicNumerals(c-b)} &nbsp;&lArr;&nbsp; س = ${toArabicNumerals(sol1)}`, comment: "حل الحالة الأولى" }
                        ],
                        case2: [
                            { eq: `<div class='fraction'><span class='numerator'>س</span><span class='denominator'>${toArabicNumerals(a)}</span></div> + ${toArabicNumerals(b)} = ${toArabicNumerals(-c)}`, comment: "الحالة الثانية" },
                            { eq: `<div class='fraction'><span class='numerator'>س</span><span class='denominator'>${toArabicNumerals(a)}</span></div> = ${toArabicNumerals(-c-b)} &nbsp;&lArr;&nbsp; س = ${toArabicNumerals(sol2)}`, comment: "حل الحالة الثانية" }
                        ],
                        final: { eq: `مجموعة الحل هي ${formatAnswer(answer)}`, comment: "النتيجة النهائية" }
                    };
                    break;
                }
                case 'eq_plus_d': { // |2س - b| + d = c
                    const a = 2;
                    const b = Math.floor(Math.random() * 5) * 2 + 1; // Random odd
                    const d = Math.floor(Math.random() * 5) + 1; // 1 to 5
                    const c_new = Math.floor(Math.random() * 5) * 2 + 1; // Random odd
                    const c = c_new + d;
                    const sol1 = (c_new + b) / a;
                    const sol2 = (-c_new + b) / a;
                    html = `<span class="abs-bars">|</span> ${toArabicNumerals(a)}س - ${toArabicNumerals(b)} <span class="abs-bars">|</span> + ${toArabicNumerals(d)}`;
                    rhs = `= ${toArabicNumerals(c)}`;
                    answer = [sol1, sol2];
                    steps = {
                        initial: [
                            { eq: `| ${toArabicNumerals(a)}س - ${toArabicNumerals(b)} | = ${toArabicNumerals(c)} - ${toArabicNumerals(d)}`, comment: "أولاً، نعزل القيمة المطلقة" },
                            { eq: `| ${toArabicNumerals(a)}س - ${toArabicNumerals(b)} | = ${toArabicNumerals(c_new)}`, comment: "الآن نحل المعادلة" }
                        ],
                        case1: [
                            { eq: `${toArabicNumerals(a)}س - ${toArabicNumerals(b)} = ${toArabicNumerals(c_new)}`, comment: "الحالة الأولى" },
                            { eq: `س = ${toArabicNumerals(sol1)}`, comment: "حل الحالة الأولى" }
                        ],
                        case2: [
                            { eq: `${toArabicNumerals(a)}س - ${toArabicNumerals(b)} = ${toArabicNumerals(-c_new)}`, comment: "الحالة الثانية" },
                            { eq: `س = ${toArabicNumerals(sol2)}`, comment: "حل الحالة الثانية" }
                        ],
                        final: { eq: `مجموعة الحل هي ${formatAnswer(answer)}`, comment: "النتيجة النهائية" }
                    };
                    break;
                }
            }
            return { html, rhs, answer, steps };
        }

        function generateOptions(correctAnswer) {
            const correctAnswerString = formatAnswer(correctAnswer);
            let options = new Set([correctAnswerString]);

            // Generate more plausible distractors
            if (Array.isArray(correctAnswer) && correctAnswer.length === 2) {
                const [sol1, sol2] = correctAnswer; // No need to sort here
                // Distractor 1: Flipped signs
                options.add(formatAnswer([-sol1, -sol2]));
                // Distractor 2: One correct, one flipped
                options.add(formatAnswer([sol1, -sol2]));
                // Distractor 3: Single solution
                options.add(formatAnswer([sol1]));
                 options.add(formatAnswer([sol2]));
            } else { // For "No solution"
                 const num1 = Math.floor(Math.random() * 10) - 5;
                let num2 = num1;
                while(num2 === num1) { num2 = Math.floor(Math.random() * 10) - 5; }
                options.add(formatAnswer([num1, num2]));
                options.add(formatAnswer([-num1, -num2]));
                options.add(formatAnswer([num1]));
            }
            
            // Ensure we don't have duplicate options before converting to array
            let finalOptions = Array.from(options);
            
            // If we have too many options, prioritize keeping the correct answer and varied distractors
            while(finalOptions.length > 4) {
                 for(let i = finalOptions.length - 1; i >= 0; i--) {
                    if(finalOptions[i] !== correctAnswerString) {
                        finalOptions.splice(i, 1);
                        break;
                    }
                }
            }

            // If we have too few options, add random ones
             while (finalOptions.length < 4) {
                const num1 = Math.floor(Math.random() * 15) - 7;
                const num2 = Math.floor(Math.random() * 15) - 7;
                let newOption;
                if (num1 !== num2 && Math.random() > 0.5) {
                    newOption = formatAnswer([num1, num2]);
                } else {
                    newOption = formatAnswer([num1]);
                }
                if(!finalOptions.includes(newOption)) {
                    finalOptions.push(newOption);
                }
            }

            return finalOptions.sort(() => Math.random() - 0.5);
        }

        function displayNewQuestion() {
            stageInfoElement.innerText = `المرحلة ${toArabicNumerals(currentStage)} - السؤال ${toArabicNumerals(questionIndex + 1)} / ${toArabicNumerals(problemsPerStage[currentStage - 1])}`;
            currentProblem = generateProblem(currentStage);
            questionElement.innerHTML = currentProblem.html + currentProblem.rhs;

            const options = generateOptions(currentProblem.answer);
            optionsContainer.innerHTML = '';
            options.forEach(option => {
                const button = document.createElement('button');
                button.className = 'option-button';
                button.innerHTML = option;
                button.onclick = () => checkAnswer(option);
                optionsContainer.appendChild(button);
            });
            startTimer();
            whistle.triggerAttackRelease("A5", "0.3");
        }
        
        function checkAnswer(selectedAnswer) {
            stopTimer();
            document.querySelectorAll('#optionsContainer .option-button').forEach(b => b.disabled = true);
            knowWhyButton.style.visibility = 'visible';

            const correctAnswerString = formatAnswer(currentProblem.answer);

            if (selectedAnswer === correctAnswerString) {
                score++;
                updateScoreDisplay();
                shootBall('save'); // Correct answer = save
                saveMessageElement.style.display = 'block';
            } else {
                shootBall('goal'); // Incorrect answer = goal
                goalMessageElement.style.display = 'block';
                document.querySelectorAll('#optionsContainer .option-button').forEach(b => {
                    if (b.innerHTML === correctAnswerString) {
                        b.classList.add('correct-answer');
                    }
                });
            }
        }

        function showSolution() {
            clearTimeout(resetTimeoutId);
            resetTimeoutId = null;
            solutionQuestion.innerHTML = currentProblem.html + currentProblem.rhs;
            const steps = currentProblem.steps;
            solutionSteps.innerHTML = ''; // Clear previous steps
            finalSolutionStep.innerHTML = '';

            if (Array.isArray(steps)) { // Single case (e.g., no solution)
                steps.forEach(step => {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = 'solution-step';
                    stepDiv.innerHTML = `<span class="solution-eq">${step.eq}</span><span class="solution-comment">${step.comment}</span>`;
                    solutionSteps.appendChild(stepDiv);
                });
            } else { // Two cases
                if (steps.initial) {
                    const initialContainer = document.createElement('div');
                    steps.initial.forEach(step => {
                         const stepDiv = document.createElement('div');
                         stepDiv.className = 'solution-step';
                         stepDiv.innerHTML = `<span class="solution-eq">${step.eq}</span><span class="solution-comment">${step.comment}</span>`;
                         initialContainer.appendChild(stepDiv);
                    });
                    solutionSteps.appendChild(initialContainer);
                }

                const columnsContainer = document.createElement('div');
                columnsContainer.style.display = 'flex';
                columnsContainer.style.width = '100%';
                columnsContainer.style.gap = '20px';

                const case1Container = document.createElement('div');
                case1Container.className = 'solution-case';
                case1Container.innerHTML = '<h3>الحالة الأولى</h3>';
                steps.case1.forEach(step => {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = 'solution-step';
                    stepDiv.innerHTML = `<span class="solution-eq">${step.eq}</span><span class="solution-comment">${step.comment}</span>`;
                    case1Container.appendChild(stepDiv);
                });

                const case2Container = document.createElement('div');
                case2Container.className = 'solution-case';
                case2Container.innerHTML = '<h3>الحالة الثانية</h3>';
                steps.case2.forEach(step => {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = 'solution-step';
                    stepDiv.innerHTML = `<span class="solution-eq">${step.eq}</span><span class="solution-comment">${step.comment}</span>`;
                    case2Container.appendChild(stepDiv);
                });
                
                columnsContainer.appendChild(case1Container);
                columnsContainer.appendChild(case2Container);
                solutionSteps.appendChild(columnsContainer);

                finalSolutionStep.innerHTML = `<span class="solution-eq">${steps.final.eq}</span><span class="solution-comment">${steps.final.comment}</span>`;
            }

            solutionScreen.classList.add('visible');
        }

        function closeSolution() {
            solutionScreen.classList.remove('visible');
            setTimeout(() => resetGame(false), 500);
        }


        function updateScoreDisplay(isReset = false) {
            scoreValueElement.innerText = toArabicNumerals(score);
            if (!isReset) {
                scoreValueElement.classList.add('score-updated');
                setTimeout(() => {
                    scoreValueElement.classList.remove('score-updated');
                }, 500);
            }
        }

        function startTimer() {
            timeLeft = TIME_PER_QUESTION;
            timerValueElement.innerText = toArabicNumerals(timeLeft);
            timerDisplay.classList.remove('warning');

            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timeLeft--;
                timerValueElement.innerText = toArabicNumerals(timeLeft);
                if (timeLeft <= 5) {
                    timerDisplay.classList.add('warning');
                }
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    checkAnswer(null); // Pass null for timeout
                }
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function shootBall(type) {
            if (isBallShot) return;
            isBallShot = true;
            isKeeperReacting = true;
            shotTypeGlobal = type;
            
            let shotTarget = new THREE.Vector3();

            // The logic is now INVERTED
            if (type === 'goal') { // Incorrect answer
                const goalSide = Math.random() < 0.5 ? -1 : 1;
                shotTarget.set((goalWidth / 2 * 0.8) * goalSide, goalHeight * 0.8, goalLineZ - 0.5);
                keeperTarget.set(shotTarget.x * -1, shotTarget.y, goalLineZ); // Keeper dives the wrong way
                ballVelocity = shotTarget.clone().sub(ball.position).normalize().multiplyScalar(0.75);
            } else { // 'save' - Correct answer
                const diveX = THREE.MathUtils.randFloat(-2.0, 2.0);
                const diveY = THREE.MathUtils.randFloat(0.5, 1.8);
                keeperTarget.set(diveX, diveY, goalLineZ); // Keeper dives correctly
                shotTarget.copy(keeperTarget).y += 0.2; // Ball is shot towards the keeper
                ballVelocity = shotTarget.clone().sub(ball.position).normalize().multiplyScalar(0.6);
                triggerSaveEffects(); // Celebrate the save
            }
        }

        function resetGame(isInitial = false) {
            clearTimeout(resetTimeoutId);
            resetTimeoutId = null;
            isResetting = false;

            if (goalMessageElement) goalMessageElement.style.display = 'none';
            if (saveMessageElement) saveMessageElement.style.display = 'none';

            isBallShot = false;
            isKeeperReacting = false;
            keeperSaved = false;
            goalScored = false;
            hasHitNet = false;
            ball.position.set(0, ballRadius, 7);
            ballVelocity.set(0, 0, 0);
            keeperGroup.position.copy(initialKeeperPosition);
            knowWhyButton.style.visibility = 'hidden';
            
            if (!isInitial) {
                questionIndex++;
                if (questionIndex >= problemsPerStage[currentStage - 1]) {
                    if (currentStage < 2) {
                        infoContainer.style.visibility = 'hidden';
                        mathContainer.style.visibility = 'hidden';
                        showStageIntro(2);
                    } else {
                        showFinalScore();
                    }
                } else {
                    displayNewQuestion();
                }
            }
        }

        function showFinalScore() {
            infoContainer.style.visibility = 'hidden';
            mathContainer.style.visibility = 'hidden';
            clearInterval(totalTimeInterval);
            
            let feedback = '';
            if (score >= 9) {
                feedback = excellentFeedback[Math.floor(Math.random() * excellentFeedback.length)];
            } else if (score >= 6) {
                feedback = goodFeedback[Math.floor(Math.random() * goodFeedback.length)];
            } else if (score >= 3) {
                feedback = needsImprovementFeedback[Math.floor(Math.random() * needsImprovementFeedback.length)];
            } else {
                feedback = lowFeedback[Math.floor(Math.random() * lowFeedback.length)];
            }
            feedbackText.innerText = feedback;
            
            finalScoreScreen.classList.add('visible');
            saveAndFinishGame(score, totalGameTime);
        }

        function handleCollision() {
            saveSound.triggerAttackRelease("C2", "0.5");
            keeperSaved = true;
            isKeeperReacting = false;
            const reboundDirection = new THREE.Vector3(
                THREE.MathUtils.randFloat(-1, 1),
                THREE.MathUtils.randFloat(0.5, 1.2),
                THREE.MathUtils.randFloat(0.8, 1.5)
            );
            reboundDirection.normalize();
            ballVelocity.copy(reboundDirection).multiplyScalar(0.8);
        }
        
        function triggerSaveEffects() { // Renamed from triggerGoalEffects
            flashGoalposts();
            createConfetti();
            crowdCheer.triggerAttackRelease("2.5s");
        }
        
        function shakeGoalposts() {
            const posts = [leftPost, rightPost, crossbar];
            const initialPositions = {
                left: leftPost.position.clone(),
                right: rightPost.position.clone(),
                crossbar: crossbar.position.clone()
            };
            const shakeIntensity = 0.05;
            let shakeDuration = 400; // 0.4 seconds
            const startTime = Date.now();

            function shake() {
                const elapsedTime = Date.now() - startTime;
                if (elapsedTime >= shakeDuration) {
                    leftPost.position.copy(initialPositions.left);
                    rightPost.position.copy(initialPositions.right);
                    crossbar.position.copy(initialPositions.crossbar);
                    return;
                }

                const shakeX = (Math.random() - 0.5) * shakeIntensity;
                const shakeY = (Math.random() - 0.5) * shakeIntensity;

                leftPost.position.set(initialPositions.left.x + shakeX, initialPositions.left.y + shakeY, initialPositions.left.z);
                rightPost.position.set(initialPositions.right.x + shakeX, initialPositions.right.y + shakeY, initialPositions.right.z);
                crossbar.position.set(initialPositions.crossbar.x + shakeX, initialPositions.crossbar.y + shakeY, initialPositions.crossbar.z);

                requestAnimationFrame(shake);
            }

            shake();
        }


        function flashGoalposts() {
            const posts = [leftPost, rightPost, crossbar];
            const originalEmissive = posts[0].material.emissive.getHex();
            
            let flashes = 0;
            const maxFlashes = 4;
            const flashInterval = setInterval(() => {
                posts.forEach(p => {
                    p.material.emissive.setHex(flashes % 2 === 0 ? 0xFFFF00 : originalEmissive);
                });
                flashes++;
                if (flashes >= maxFlashes) {
                    clearInterval(flashInterval);
                }
            }, 150);
        }

        function createConfetti() {
            const confettiCount = 150;
            const confettiGeometry = new THREE.PlaneGeometry(0.1, 0.1);
            const colors = [0xffd700, 0xff69b4, 0x00bfff, 0x7cfc00, 0xff4500];

            for (let i = 0; i < confettiCount; i++) {
                const confettiMaterial = new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)], side: THREE.DoubleSide });
                const confetti = new THREE.Mesh(confettiGeometry, confettiMaterial);
                
                confetti.position.set(
                    THREE.MathUtils.randFloatSpread(15),
                    THREE.MathUtils.randFloat(10, 15),
                    THREE.MathUtils.randFloatSpread(5)
                );

                const particle = {
                    mesh: confetti,
                    velocity: new THREE.Vector3(
                        THREE.MathUtils.randFloatSpread(0.02),
                        -0.05 - Math.random() * 0.05,
                        THREE.MathUtils.randFloatSpread(0.02)
                    ),
                    rotationSpeed: new THREE.Vector3(
                        Math.random() * 0.1,
                        Math.random() * 0.1,
                        Math.random() * 0.1
                    )
                };
                confettiParticles.push(particle);
                confettiGroup.add(confetti);
            }
        }


        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const time = Date.now() * 0.001;

            attackers.forEach(player => {
                player.mesh.position.y = Math.sin(time * 2 + player.offset) * 0.1; // Gentle up-down bobbing
            });

            flags.forEach(flag => {
                const position = flag.geometry.attributes.position;
                const time = Date.now() * 0.005;
                for (let i = 0; i < position.count; i++) {
                    const x = position.getX(i);
                    const y = Math.sin(x * 2 + time) * 0.2;
                    position.setY(i, y);
                }
                position.needsUpdate = true;
            });


            for (let i = confettiParticles.length - 1; i >= 0; i--) {
                const particle = confettiParticles[i];
                particle.mesh.position.add(particle.velocity);
                particle.mesh.rotation.x += particle.rotationSpeed.x;
                particle.mesh.rotation.y += particle.rotationSpeed.y;
                particle.mesh.rotation.z += particle.rotationSpeed.z;

                if (particle.mesh.position.y < -2) {
                    confettiGroup.remove(particle.mesh);
                    confettiParticles.splice(i, 1);
                }
            }

            if (isKeeperReacting && !keeperSaved && !goalScored) {
                keeperGroup.position.lerp(keeperTarget, 0.08);
                const ballSphere = new THREE.Sphere(ball.position, ballRadius);
                auraBoundingBox.setFromObject(collisionAura);
                if (auraBoundingBox.intersectsSphere(ballSphere)) {
                    if (shotTypeGlobal === 'save') { // Only handle collision on a save attempt
                         handleCollision();
                    }
                }
            }
            
            if (isBallShot) {
                if (!goalScored && !keeperSaved) {
                    if (ball.position.z <= 0 + ballRadius && Math.abs(ball.position.x) < goalWidth / 2 && ball.position.y < goalHeight) {
                        goalScored = true;
                        shakeGoalposts(); // Shake goal on score
                    }
                }
                
                if (goalScored && !hasHitNet) {
                    if (ball.position.z <= -netDepth + ballRadius) {
                        hasHitNet = true;
                        netSound.triggerAttackRelease("8n");
                        ballVelocity.multiplyScalar(1.0 - 0.88);
                        ballVelocity.z *= -1;
                    }
                    if (Math.abs(ball.position.x) >= goalWidth / 2 - ballRadius) {
                         ballVelocity.x *= -0.8;
                    }
                     if (ball.position.y >= goalHeight - ballRadius) {
                         ballVelocity.y *= -0.8;
                    }
                }

                const horizontalVelocity = new THREE.Vector3(ballVelocity.x, 0, ballVelocity.z);
                const speed = horizontalVelocity.length();
                if (speed > 0.001) {
                    const distance = speed;
                    const rotationAngle = distance / ballRadius;
                    const rotationAxis = new THREE.Vector3().crossVectors(horizontalVelocity, new THREE.Vector3(0, 1, 0)).normalize();
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromAxisAngle(rotationAxis, rotationAngle);
                    ball.quaternion.premultiply(quaternion);
                }

                ballVelocity.add(gravity);
                ball.position.add(ballVelocity);

                if (ball.position.y < ballRadius) {
                    ball.position.y = ballRadius;
                    ballVelocity.y *= -0.4; 
                    ballVelocity.x *= 0.96; 
                    ballVelocity.z *= 0.96;
                }
            }

            const outOfBounds = ball.position.z < -netDepth - 2 || ball.position.z > 15 || Math.abs(ball.position.x) > 15;
            const goalRollStopped = goalScored && ball.position.y <= ballRadius && ballVelocity.length() < 0.02;
            if (isBallShot && !isResetting && (outOfBounds || (keeperSaved && ball.position.z > 10) || goalRollStopped)) {
                isResetting = true;
                resetTimeoutId = setTimeout(() => {
                    resetGame(false);
                }, 3000);
            }

            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        init();
    </script>
    
    <!-- --- START OF CONNECTION & LEADERBOARD ENGINE --- -->
    <script>
    (function() {
        // --- CONFIGURATION (عدّل هذه الإعدادات لكل لعبة) ---
        const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzrf1-At3Pq7i39bGV3F1iD3-b0G-WWyRi5cgpKeQjyn_N5fh2EmGhoyRKUsbLd-F_UJQ/exec";
        const GAME_ID = 'g1_5_2';         // مثال: 'g1_1_1'
        const GAME_MAX_POINTS = 10;                     // أقصى نقاط في اللعبة
        const PLATFORM_MAX_GRADE = 5;                   // الدرجة النهائية في المنصة
        const METRIC_TYPE = 'time';                     // نوع المعيار: 'time', 'stars', 'errors'
        const METRIC_LABEL = 'الوقت (ثواني)';           // اسم المعيار للعرض في الجدول

        let currentUser = null;

        // --- CORE FUNCTIONS ---

        // 1. الدالة الرئيسية التي تستدعيها عند انتهاء اللعبة
        window.saveAndFinishGame = function(points, metricValue) {
            const finalPoints = parseFloat(points) || 0;
            const finalMetric = parseFloat(metricValue) || 0;
            const maxPoints = parseFloat(GAME_MAX_POINTS) || 1;
            const finalGrade = (finalPoints / maxPoints) * PLATFORM_MAX_GRADE;

            const resultDisplay = document.getElementById('final-result-display');
            if (resultDisplay) {
                resultDisplay.innerHTML = `
                    <p class="text-white">النقاط: <span class="font-bold text-xl">${finalPoints} / ${maxPoints}</span></p>
                    <p class="text-blue-400">الدرجة في المنصة: <span class="font-bold text-2xl">${finalGrade.toFixed(1)} / ${PLATFORM_MAX_GRADE}</span></p>
                `;
            }

            if (currentUser && currentUser.id) {
                const params = new URLSearchParams({
                    action: 'saveGrade',
                    studentId: currentUser.id,
                    itemId: GAME_ID,
                    grade: finalGrade.toFixed(2),
                    metricValue: finalMetric.toString()
                });
                fetch(`${SCRIPT_URL}?${params.toString()}`)
                    .then(res => res.json())
                    .then(result => console.log('Save result:', result.status))
                    .catch(err => console.error("Save Error:", err))
                    .finally(fetchAndShowLeaderboard);
            } else {
                console.log(`Visitor finished. Score: ${finalPoints}, Metric: ${finalMetric}`);
                fetchAndShowLeaderboard();
            }
        }

        // 2. دالة جلب وعرض سجل الأبطال
        function fetchAndShowLeaderboard() {
            const loader = document.getElementById('leaderboard-loader');
            const container = document.getElementById('leaderboard-container');
            if (!loader || !container) return;

            loader.style.display = 'block';
            container.innerHTML = '';

            const params = new URLSearchParams({
                action: 'getLeaderboard',
                gameId: GAME_ID,
                metricType: METRIC_TYPE
            });

            fetch(`${SCRIPT_URL}?${params.toString()}`)
                .then(res => res.json())
                .then(response => {
                    if (response.status === 'success' && response.data) {
                        displayLeaderboard(response.data);
                    } else {
                        throw new Error(response.message || 'Failed to load leaderboard data.');
                    }
                })
                .catch(err => {
                    console.error("Leaderboard Error:", err);
                    container.innerHTML = `<p class="text-center text-red-500">حدث خطأ في تحميل سجل الأبطال.</p>`;
                })
                .finally(() => {
                    loader.style.display = 'none';
                    showFinishButton();
                });
        }
        
        // 3. دالة بناء جدول سجل الأبطال
        function displayLeaderboard(data) {
            const container = document.getElementById('leaderboard-container');
            if (!data || data.length === 0) {
                container.innerHTML = `<p class="text-center text-gray-400 mt-4">لا توجد نتائج بعد. كن أول الأبطال!</p>`;
                return;
            }

            let tableHTML = `
                <div class="mt-6 border-t border-gray-700 pt-4">
                    <h3 class="text-2xl font-bold text-center text-white mb-4">🏆 سجل الأبطال 🏆</h3>
                    <table class="min-w-full bg-gray-800 bg-opacity-50 shadow-md rounded-lg">
                        <thead class="bg-gray-900 text-white">
                            <tr>
                                <th class="text-center py-2 px-3">الترتيب</th>
                                <th class="text-right py-2 px-3">اسم الطالب</th>
                                <th class="text-center py-2 px-3">الدرجة</th>
                                <th class="text-center py-2 px-3">${METRIC_LABEL}</th>
                            </tr>
                        </thead>
                        <tbody class="text-gray-300">`;

            data.forEach((player, index) => {
                const rank = index + 1;
                let rankDisplay = rank;
                if (rank === 1) rankDisplay = '🥇';
                if (rank === 2) rankDisplay = '🥈';
                if (rank === 3) rankDisplay = '🥉';

                const isCurrentUser = (currentUser && player.name === currentUser.name);
                const rowClass = isCurrentUser ? 'bg-blue-500 bg-opacity-30 font-bold' : (index % 2 === 0 ? 'bg-gray-700 bg-opacity-50' : '');

                tableHTML += `
                    <tr class="${rowClass}">
                        <td class="text-center py-2 px-3 text-xl">${rankDisplay}</td>
                        <td class="text-right py-2 px-3">${player.name}</td>
                        <td class="text-center py-2 px-3">${player.grade.toFixed(1)}</td>
                        <td class="text-center py-2 px-3">${player.metricValue}</td>
                    </tr>`;
            });

            tableHTML += `</tbody></table></div>`;
            container.innerHTML = tableHTML;
        }

        // 4. إظهار زر الإنهاء
        function showFinishButton() {
            const finishWrapper = document.getElementById('finish-game-wrapper');
            if (finishWrapper) {
                finishWrapper.style.display = 'block';
            }
        }

        // 5. استقبال بيانات الطالب من المنصة الرئيسية
        window.addEventListener('message', (event) => {
            if (event.data && event.data.event === 'userData') {
                currentUser = event.data.data;
                console.log('User data received:', currentUser);
            }
        });

        // 6. التعامل مع زر الإنهاء
        document.addEventListener('DOMContentLoaded', () => {
            const finishBtn = document.getElementById('finish-game-btn');
            if (finishBtn) {
                finishBtn.addEventListener('click', () => {
                    window.parent.postMessage({ event: 'gameFinished', gameId: GAME_ID }, '*');
                });
            }
        });
    })();
    </script>
    <!-- --- END OF CONNECTION & LEADERBOARD ENGINE --- -->
</body>
</html>
