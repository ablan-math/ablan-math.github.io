<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù„Ø¹Ø¨Ø© Ø§Ù„Ø·Ø§Ø¦Ø±Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©</title>
    <style>
        /* --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„ØµÙØ­Ø© --- */
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #87CEEB; /* Ù„ÙˆÙ† Ø§Ù„Ø³Ù…Ø§Ø¡ */
            font-family: 'Cairo', sans-serif; /* Ø®Ø· Ø¹Ø±Ø¨ÙŠ Ø¬Ù…ÙŠÙ„ */
            overflow: hidden;
            color: #fff;
        }

        /* --- Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© --- */
        #game-container {
            position: relative;
            width: 100%;
            max-width: 800px; /* ØªØ­Ø¯ÙŠØ¯ Ø¹Ø±Ø¶ Ø£Ù‚ØµÙ‰ Ù„Ù„Ø¹Ø¨Ø© */
            height: 100%;
            max-height: 600px;
            background: linear-gradient(to bottom, #87CEEB 0%, #B0E0E6 100%); /* ØªØ¯Ø±Ø¬ Ù„ÙˆÙ† Ø§Ù„Ø³Ù…Ø§Ø¡ */
            border: 5px solid #fff;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            overflow: hidden; /* Ø¥Ø®ÙØ§Ø¡ Ø£ÙŠ Ø¹Ù†Ø§ØµØ± ØªØ®Ø±Ø¬ Ø¹Ù† Ø¥Ø·Ø§Ø± Ø§Ù„Ù„Ø¹Ø¨Ø© */
        }

        /* --- Ù„ÙˆØ­Ø© Ø§Ù„Ø±Ø³Ù… (Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³) --- */
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: transparent;
        }

        /* --- ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ù„Ø±Ø³Ø§Ø¦Ù„) --- */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            pointer-events: none; /* Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù†Ù‚Ø±Ø§Øª Ø¨Ø§Ù„Ù…Ø±ÙˆØ± Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³ */
        }

        /* --- Ø´Ø±ÙŠØ· Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¹Ù„ÙˆÙŠ --- */
        #top-bar {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 10px;
        }

        #equation-display, #task-display {
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        #task-display {
            font-size: clamp(1rem, 3.5vw, 1.4rem);
            color: #FFD700;
        }

        /* --- Ø¹Ø±Ø¶ Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ù„ØµØ­Ø© --- */
        #stats-container {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
        }

        #score, #health {
            font-size: clamp(1.4rem, 4.5vw, 2rem);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            background-color: rgba(0, 0, 0, 0.2);
            padding: 5px 20px;
            border-radius: 10px;
        }

        /* --- Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù„Ø¹Ø¨Ø© (Ø§Ù„Ø¨Ø¯Ø¡ØŒ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©) --- */
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: all;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            border: 2px solid white;
            width: 90%;
            max-width: 550px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #message-box h1 { margin: 0 0 10px 0; font-size: clamp(1.8rem, 5vw, 2.2rem); }
        #message-box p { margin: 0 0 20px 0; font-size: clamp(1rem, 3vw, 1.2rem); }

        /* --- Ø£Ø²Ø±Ø§Ø± Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø© --- */
        #end-game-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 20px;
            width: 100%;
        }
        #restart-button, #finish-game-btn {
            padding: 12px 25px;
            font-size: 1.1rem;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        #restart-button {
            background-color: #FFD700;
            color: #333;
        }
        #finish-game-btn {
            background-color: #6c757d;
            color: white;
        }
        #restart-button:hover { transform: scale(1.05); background-color: #FFC700; }
        #finish-game-btn:hover { transform: scale(1.05); background-color: #5a6268; }
        
        /* --- Ø£Ù†Ù…Ø§Ø· Ø³Ø¬Ù„ Ø§Ù„Ø£Ø¨Ø·Ø§Ù„ ÙˆÙ…Ø­Ø±Ùƒ Ø§Ù„Ø±Ø¨Ø· --- */
        .text-center { text-align: center; }
        .text-right { text-align: right; }
        .font-bold { font-weight: bold; }
        .mt-4 { margin-top: 1rem; }
        .mt-6 { margin-top: 1.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .pt-4 { padding-top: 1rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
        .border-t { border-top: 1px solid #e5e7eb; }
        .text-xl { font-size: 1.25rem; }
        .text-2xl { font-size: 1.5rem; }
        .text-gray-700 { color: #374151; }
        .text-gray-800 { color: #1f2937; }
        .text-gray-500 { color: #6b7280; }
        .text-blue-600 { color: #2563EB; }
        .text-red-500 { color: #ef4444; }
        .text-white { color: #ffffff; }
        .text-yellow-300 { color: #ca8a04; }
        
        #leaderboard-container table {
            min-width: 100%;
            background-color: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-radius: 0.5rem;
            border-collapse: collapse;
            overflow: hidden;
        }
        #leaderboard-container thead {
            background-color: #1f2937;
            color: #ffffff;
        }
        .bg-blue-100 { background-color: #dbeafe; }
        .bg-gray-100 { background-color: #f3f4f6; }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        #leaderboard-loader div {
            border-bottom-color: #1f2937;
            border-radius: 50%;
            height: 3rem;
            width: 3rem;
            border-width: 2px;
            margin-left: auto;
            margin-right: auto;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="ui-container">
            <div id="top-bar" style="visibility: hidden;">
                <div id="equation-display"></div>
                <div id="task-display"></div>
            </div>
            <div id="stats-container" style="visibility: hidden;">
                 <div id="health">Ø§Ù„ØµØ­Ø©: â¤ï¸â¤ï¸â¤ï¸</div>
                 <div id="score">Ø§Ù„Ù†Ù‚Ø§Ø·: Ù </div>
            </div>
            <div id="message-box">
                <h1>Ù„Ø¹Ø¨Ø© Ø·Ø§Ø¦Ø±Ø© Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª</h1>
                <p id="welcomeMessage">Ø­Ù„Ù‘Ù‚ Ø¨Ø·Ø§Ø¦Ø±ØªÙƒ Ø¹Ø¨Ø± Ø³Ù…Ø§Ø¡ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª ÙˆØ£Ø¬Ø¨ Ø¹Ù† Ø£Ø³Ø¦Ù„Ø© Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø®Ø· Ø§Ù„Ù…Ø³ØªÙ‚ÙŠÙ… Ù„ØªØµÙ„ Ø¥Ù„Ù‰ ÙˆØ¬Ù‡ØªÙƒ Ø¨Ø³Ù„Ø§Ù….</p>
                <div id="developer-info" class="mt-4 text-sm text-gray-500">
                    <p>ØªØ·ÙˆÙŠØ± ÙˆØ¨Ø±Ù…Ø¬Ø©: Ø§Ù„Ø£Ø³ØªØ§Ø° Ø¹Ø¨Ø¯Ø§Ù„Ø¹Ø²ÙŠØ² Ø®Ø§Ù„Ø¯ Ø§Ù„Ø¹Ø¨Ù„Ø§Ù†</p>
                </div>
                
                <!-- 1. Ù„Ø¹Ø±Ø¶ Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø·Ø§Ù„Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠØ© -->
                <div id="final-result-display" class="text-center text-xl mt-4"></div>

                <!-- 2. Ù„Ø¹Ø±Ø¶ Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ -->
                <div id="leaderboard-loader" style="display: none;" class="text-center mt-6">
                    <div class="animate-spin"></div>
                    <p>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø³Ø¬Ù„ Ø§Ù„Ø£Ø¨Ø·Ø§Ù„...</p>
                </div>

                <!-- 3. Ù„Ø¹Ø±Ø¶ Ø¬Ø¯ÙˆÙ„ Ø³Ø¬Ù„ Ø§Ù„Ø£Ø¨Ø·Ø§Ù„ -->
                <div id="leaderboard-container" class="mt-4"></div>

                <!-- 4. Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© -->
                <div id="end-game-buttons">
                    <button id="restart-button">Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
                </div>
                <div id="finish-game-wrapper" style="display: none;" class="mt-4">
                     <button id="finish-game-btn">Ø¥Ù†Ù‡Ø§Ø¡ ÙˆØ§Ù„Ø¹ÙˆØ¯Ø©</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');

        // --- Ø¹Ù†Ø§ØµØ± ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ---
        const scoreEl = document.getElementById('score');
        const healthEl = document.getElementById('health');
        const messageBox = document.getElementById('message-box');
        const restartButton = document.getElementById('restart-button');
        const equationDisplay = document.getElementById('equation-display');
        const taskDisplay = document.getElementById('task-display');
        const topBar = document.getElementById('top-bar');
        const statsContainer = document.getElementById('stats-container');

        let canvasWidth, canvasHeight;
        
        // --- Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø© ---
        let score = 0;
        let errors = 0; // ** Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ (Ø§Ù„Ù…Ø¹ÙŠØ§Ø± Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ) **
        let gameOver = true;
        let clouds = [];
        let particles = [];
        let frame = 0;
        let keys = {};
        let fireworksInterval = null;
        
        let backgroundSpeedLandmark = 0.2;
        let backgroundSpeedBack = 0.5;
        let backgroundSpeedFront = 0.8;
        let cityOffsetLandmark = 0;
        let cityOffsetBack = 0;
        let cityOffsetFront = 0;

        // --- Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ© ---
        let currentProblemIndex = 0;
        let currentProblem; 
        let slopeCollected = false;
        let interceptCollected = false;
        const totalProblems = 5;

        // --- Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© ---
        function toArabicNumerals(num) {
            const arabicNumerals = ['Ù ', 'Ù¡', 'Ù¢', 'Ù£', 'Ù¤', 'Ù¥', 'Ù¦', 'Ù§', 'Ù¨', 'Ù©'];
            let str = String(num);
            const isNegative = str.startsWith('-');
            if (isNegative) str = str.substring(1);
            str = str.replace(/[0-9]/g, d => arabicNumerals[parseInt(d)]);
            return isNegative ? 'âˆ’' + str : str;
        }

        function getRandomInt(min, max, exclude = []) {
            let num;
            do {
                num = Math.floor(Math.random() * (max - min + 1)) + min;
            } while (exclude.includes(num));
            return num;
        }

        // --- Ø¶Ø¨Ø· Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³ Ø¨Ø´ÙƒÙ„ Ù…ØªØ¬Ø§ÙˆØ¨ ---
        function resizeCanvas() {
            canvasWidth = gameContainer.clientWidth;
            canvasHeight = gameContainer.clientHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // ** ØªØ­Ø¯ÙŠØ« Ø­Ø¬Ù… Ø§Ù„Ø·Ø§Ø¦Ø±Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø­Ø¬Ù… Ø§Ù„Ø´Ø§Ø´Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯ **
            plane.width = canvasWidth * 0.12;
            plane.height = plane.width * 0.5;
        }
        window.addEventListener('resize', resizeCanvas);
        

        // --- Ø§Ù„Ø·Ø§Ø¦Ø±Ø© (Ø§Ù„Ù„Ø§Ø¹Ø¨) ---
        const plane = {
            x: 0, y: 0, 
            width: 80, height: 40, // ** Ø³ÙŠØªÙ… ØªØ­Ø¯ÙŠØ«Ù‡Ø§ ÙÙŠ resizeCanvas **
            verticalSpeed: 6, health: 3, isExploded: false,
            draw() {
                if(this.isExploded) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = '#c9302c';
                ctx.beginPath();
                ctx.moveTo(this.width * 0.1, 0);
                ctx.lineTo(this.width * 0.1, -this.height * 0.6);
                ctx.lineTo(this.width * 0.3, 0);
                ctx.fill();
                ctx.fillStyle = '#b52b27';
                ctx.fillRect(this.width * 0.4, -this.height * 0.1, this.width * 0.2, -this.height * 0.7);
                ctx.fillStyle = '#d9534f';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(this.width * 0.7, -this.height * 0.5, this.width, 0);
                ctx.quadraticCurveTo(this.width * 0.7, this.height * 0.5, 0, 0);
                ctx.fill();
                ctx.fillStyle = '#c9302c';
                ctx.fillRect(this.width * 0.4, this.height * 0.1, this.width * 0.2, this.height * 0.8);
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.arc(this.width, 0, this.height * 0.125, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            },
            update() {
                if (keys['ArrowUp'] || keys['w']) this.y -= this.verticalSpeed;
                if (keys['ArrowDown'] || keys['s']) this.y += this.verticalSpeed;
                if (this.y < 0) this.y = 0;
                if (this.y > canvasHeight - this.height) this.y = canvasHeight - this.height;
            }
        };
        
        resizeCanvas(); // ** Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø£ÙˆÙ„ÙŠ Ù„Ø¶Ø¨Ø· Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ **

        // --- Ø¬Ø²ÙŠØ¦Ø§Øª Ø§Ù„Ø¯Ø®Ø§Ù† ÙˆØ§Ù„Ø§Ù†ÙØ¬Ø§Ø± ÙˆØ§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø§Ù„Ù†Ø§Ø±ÙŠØ© ---
        class Particle {
            constructor(x, y, color, size, speedX, speedY, type = 'smoke') {
                this.x = x; this.y = y; this.color = color; this.size = size;
                this.speedX = speedX; this.speedY = speedY; this.life = 1;
                this.type = type;
                this.gravity = 0.1;
            }
            update() {
                if (this.type === 'firework') {
                    this.speedY += this.gravity;
                }
                this.x += this.speedX;
                this.y += this.speedY;
                this.life -= 0.02;
                if (this.size > 0.2 && this.type !== 'firework') this.size -= 0.1;
            }
            draw() {
                ctx.fillStyle = this.color; ctx.globalAlpha = this.life;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill(); ctx.globalAlpha = 1;
            }
        }

        // --- Ø§Ù„Ø³Ø­Ø¨ (Ø§Ù„Ø¹Ù‚Ø¨Ø§Øª ÙˆØ§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª) ---
        class Cloud {
            constructor(text, isCorrect, answerType, initialX) {
                // ** ØªØ¹Ø¯ÙŠÙ„: Ø­Ø¬Ù… Ø§Ù„ØºÙŠÙˆÙ… Ù…ØªØ¬Ø§ÙˆØ¨ **
                this.width = canvasWidth * 0.25;
                this.height = this.width * 0.6;
                this.x = initialX;
                this.y = Math.random() * (canvasHeight - this.height * 1.5) + this.height * 0.5;
                this.speed = Math.random() * 0.5 + 0.8; 
                this.color = '#FFFFFF';
                this.isCollected = false; 
                this.isHit = false; 
                this.text = text;
                this.isCorrect = isCorrect;
                this.answerType = answerType;
            }
            update() {
                this.x -= this.speed;
            }
            draw() {
                const yPos = this.y + this.height / 2 - 5; 
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.arc(this.x + this.width * 0.25, this.y + this.height * 0.5, this.width * 0.25, Math.PI, Math.PI * 2);
                ctx.arc(this.x + this.width * 0.5, this.y + this.height * 0.3, this.width * 0.3, Math.PI, Math.PI * 2);
                ctx.arc(this.x + this.width * 0.75, this.y + this.height * 0.5, this.width * 0.25, Math.PI, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                ctx.fillStyle = '#333';
                // ** ØªØ¹Ø¯ÙŠÙ„: Ø­Ø¬Ù… Ø§Ù„Ø®Ø· Ù…ØªØ¬Ø§ÙˆØ¨ **
                const fontSize = this.width * 0.15;
                ctx.font = `bold ${fontSize}px Cairo`;
                ctx.textBaseline = 'middle';
                
                if (this.text.den) {
                    drawFraction(this.text.prefix, this.text.val, this.text.den, this.x + this.width / 2, yPos, fontSize);
                } else {
                    ctx.textAlign = 'center';
                    ctx.fillText(this.text.prefix + toArabicNumerals(this.text.val), this.x + this.width / 2, yPos);
                }
            }
        }
        
        // --- Ø¯Ø§Ù„Ø© Ø±Ø³Ù… Ø§Ù„ÙƒØ³ÙˆØ± ---
        function drawFraction(prefix, num, den, x, y, fontSize) {
            const numArabic = toArabicNumerals(num);
            const denArabic = toArabicNumerals(den);
            
            ctx.textAlign = 'right';
            ctx.fillText(prefix, x + (fontSize * 1.5), y); 

            ctx.textAlign = 'center';
            const fractionX = x - ctx.measureText(prefix).width + (fontSize * 0.75); 
            ctx.fillText(numArabic, fractionX, y - (fontSize * 0.5));
            ctx.fillRect(fractionX - (fontSize * 0.75), y, fontSize * 1.5, 3); 
            ctx.fillText(denArabic, fractionX, y + (fontSize * 0.75));
        }

        // --- Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø³Ø­Ø¨ ÙˆØ§Ù„Ø§ØµØ·Ø¯Ø§Ù…Ø§Øª ---
        function handleClouds() {
            for (let i = clouds.length - 1; i >= 0; i--) {
                const cloud = clouds[i];
                cloud.update();
                cloud.draw();

                if (detectCollision(plane, cloud)) {
                    if(cloud.isCollected || cloud.isHit) continue;

                    if (cloud.isCorrect) {
                        score++;
                        scoreEl.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${toArabicNumerals(score)}`;

                        if (cloud.answerType === 'slope') {
                            slopeCollected = true;
                            clouds.forEach(c => {
                                if(c.answerType === 'slope' && c.isCorrect) {
                                    c.isCollected = true;
                                    c.color = '#90EE90';
                                }
                            });
                        }
                        if (cloud.answerType === 'intercept') {
                            interceptCollected = true;
                            clouds.forEach(c => {
                                if(c.answerType === 'intercept' && c.isCorrect) {
                                    c.isCollected = true;
                                    c.color = '#90EE90';
                                }
                            });
                        }

                        if (slopeCollected && interceptCollected) {
                            setTimeout(nextProblem, 1000); 
                        }
                    } else {
                        cloud.isHit = true; 
                        cloud.color = '#FFCCCB'; 
                        plane.health--;
                        errors++; // ** Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ **
                        updateHealthDisplay();
                        if (plane.health <= 0) {
                            createExplosion(plane.x + plane.width / 2, plane.y + plane.height / 2);
                            plane.isExploded = true;
                            setTimeout(endGame, 500);
                        }
                    }
                }
                if (cloud.x < -cloud.width) {
                    clouds.splice(i, 1); 
                    createNewCloud(); 
                }
            }
        }
        
        function createNewCloud() {
             const problem = currentProblem;
             const availableAnswers = [];
             if (!slopeCollected) availableAnswers.push({ text: { prefix: 'Ù… = ', ...problem.slope }, isCorrect: true, answerType: 'slope' });
             if (!interceptCollected) availableAnswers.push({ text: { prefix: 'Ø¨ = ', ...problem.intercept }, isCorrect: true, answerType: 'intercept' });
             
             problem.distractors.forEach(d => {
                 const type = Math.random() > 0.5 ? 'slope' : 'intercept';
                 const prefix = type === 'slope' ? 'Ù… = ' : 'Ø¨ = ';
                 availableAnswers.push({ text: { prefix: prefix, ...d }, isCorrect: false, answerType: type });
             });
             
             const ans = availableAnswers[Math.floor(Math.random() * availableAnswers.length)];
             clouds.push(new Cloud(ans.text, ans.isCorrect, ans.answerType, canvasWidth + 50));
        }

        // --- ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„ØªØ§Ù„ÙŠ ---
        function nextProblem() {
            currentProblemIndex++;
            if (currentProblemIndex >= totalProblems) {
                endGame(true);
                return;
            }
            loadProblem(currentProblemIndex);
        }

        // --- ØªÙˆÙ„ÙŠØ¯ Ø³Ø¤Ø§Ù„ Ø¬Ø¯ÙŠØ¯ ---
        function generateProblem(levelIndex) {
            let slope = {};
            let intercept = {};
            let distractors = [];
            const level = levelIndex + 1;

            if (level === 5) { // Ù… = 0
                slope = { val: 0 };
                intercept = { val: getRandomInt(-9, 9, [0]) };
                distractors = [{val: 1}, {val: -1}, {val: intercept.val + 1}, {val: intercept.val - 1}, {val: -intercept.val}, {val: 2}];
            } else if (level === 4) { // Ø¯ = 0
                intercept = { val: 0 };
                slope = { val: getRandomInt(-5, 5, [0, 1, -1])};
                distractors = [{val: 1}, {val: -1}, {val: slope.val + 1}, {val: slope.val - 1}, {val: -slope.val}, {val: 2}];
            } else if (level === 3) { // ÙƒØ³ÙˆØ±
                const num = getRandomInt(1, 4);
                let den = getRandomInt(2, 5);
                while(den <= num) den = getRandomInt(2, 5);
                const sign = Math.random() > 0.5 ? 1 : -1;
                
                slope = { val: num * sign, den: den };
                intercept = { val: getRandomInt(-9, 9, [0]) };
                distractors = [{val: den, den: num}, {val: -num, den: den}, {val: num}, {val: den}, {val: intercept.val + 1}, {val: intercept.val -1}];
            } else { // Ø§Ù„Ø£ÙˆÙ„ ÙˆØ§Ù„Ø«Ø§Ù†ÙŠ
                slope = { val: getRandomInt(-5, 5, [0, 1, -1]) };
                intercept = { val: getRandomInt(-9, 9, [0]) };
                distractors = [{val: -slope.val}, {val: -intercept.val}, {val: slope.val+1}, {val: intercept.val-1}, {val: 0}, {val: 1}];
            }
            
            distractors = distractors.filter(d => {
                if (d.den) {
                    return !(d.val === slope.val && d.den === slope.den);
                }
                return d.val !== slope.val && d.val !== intercept.val;
            });

            return { slope, intercept, distractors };
        }

        // --- ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø¤Ø§Ù„ ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø³Ø­Ø¨ ---
        function loadProblem(index) {
            currentProblem = generateProblem(index); 
            const problem = currentProblem;
            slopeCollected = false;
            interceptCollected = false;
            
            let eqHTML = 'Øµ = ';
            if (problem.slope.den) {
                eqHTML += `${problem.slope.val < 0 ? 'âˆ’' : ''}<span style="display: inline-block; text-align: center; vertical-align: middle; font-size: 1.5rem; line-height: 1;">${toArabicNumerals(Math.abs(problem.slope.val))}<br>â€•<br>${toArabicNumerals(problem.slope.den)}</span> Ø³`;
            } else if (problem.slope.val !== 0) {
                const slopeText = problem.slope.val === 1 ? 'Ø³' : problem.slope.val === -1 ? '-Ø³' : toArabicNumerals(problem.slope.val) + 'Ø³';
                eqHTML += slopeText;
            }

            if (problem.intercept.val !== 0) {
                const interceptText = problem.intercept.val > 0 ? ` + ${toArabicNumerals(problem.intercept.val)}` : ` - ${toArabicNumerals(Math.abs(problem.intercept.val))}`;
                if (problem.slope.val === 0) {
                    eqHTML += interceptText.replace(' + ', '');
                } else {
                    eqHTML += interceptText;
                }
            } else if (problem.slope.val === 0) {
                eqHTML += 'Ù ';
            }
            equationDisplay.innerHTML = eqHTML;
            taskDisplay.textContent = `Ø£ÙˆØ¬Ø¯: Ù… = ØŸ ØŒ Ø¨ = ØŸ`;
            
            clouds = [];
            let answers = [];
            
            const correctSlope = { text: { prefix: 'Ù… = ', ...problem.slope }, isCorrect: true, answerType: 'slope' };
            const correctIntercept = { text: { prefix: 'Ø¨ = ', ...problem.intercept }, isCorrect: true, answerType: 'intercept' };
            
            let incorrectAnswers = [];
            problem.distractors.forEach(d => { 
                const type = Math.random() > 0.5 ? 'slope' : 'intercept';
                const prefix = type === 'slope' ? 'Ù… = ' : 'Ø¨ = ';
                incorrectAnswers.push({ text: { prefix: prefix, ...d }, isCorrect: false, answerType: type });
            });
            
            answers = incorrectAnswers.slice(0, 6); 
            answers.push(correctSlope);
            answers.push(correctIntercept);
            answers = answers.sort(() => Math.random() - 0.5);

            // ** ØªØ¹Ø¯ÙŠÙ„: ØªÙ‚Ù„ÙŠÙ„ Ø¹Ø¯Ø¯ Ø§Ù„ØºÙŠÙˆÙ… ÙˆØ²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø³Ø§ÙØ§Øª **
            for(let i = 0; i < 4; i++) { 
                const ans = answers[i];
                if (!ans) continue; // Safety check
                const initialX = canvasWidth + i * (canvasWidth / 2.5); 
                clouds.push(new Cloud(ans.text, ans.isCorrect, ans.answerType, initialX));
            }
        }

        // --- ÙƒØ´Ù Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… ---
        function detectCollision(p, c) {
             const paddingX = p.width * 0.2; const paddingY = p.height * 0.2;
             return (p.x + paddingX < c.x + c.width - paddingX &&
                     p.x + p.width - paddingX > c.x + paddingX &&
                     p.y + paddingY < c.y + c.height - paddingY &&
                     p.y + p.height - paddingY > c.y + paddingY);
        }
        
        // --- Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª ---
        function handleParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        // --- Ø¥Ù†Ø´Ø§Ø¡ ØªØ£Ø«ÙŠØ± Ø§Ù„Ø¯Ø®Ø§Ù† ---
        function handleSmoke() {
            if (plane.health < 3 && !plane.isExploded) {
                const smokeX = plane.x;
                const smokeY = plane.y + plane.height / 2;
                if (plane.health === 2 && frame % 6 === 0) {
                    particles.push(new Particle(smokeX, smokeY, '#333', 8, -2, Math.random() - 0.5));
                }
                if (plane.health === 1 && frame % 4 === 0) {
                    particles.push(new Particle(smokeX, smokeY, '#333', 9, -2.5, Math.random() - 0.5));
                    particles.push(new Particle(smokeX, smokeY, '#d9534f', 7, -2, Math.random() - 0.5));
                }
            }
        }
        
        // --- Ø¥Ù†Ø´Ø§Ø¡ ØªØ£Ø«ÙŠØ± Ø§Ù„Ø§Ù†ÙØ¬Ø§Ø± ---
        function createExplosion(x, y) {
            for (let i = 0; i < 50; i++) {
                const size = Math.random() * 10 + 5;
                const speedX = (Math.random() - 0.5) * 10;
                const speedY = (Math.random() - 0.5) * 10;
                const color = Math.random() < 0.5 ? '#FFA500' : '#FF4500';
                particles.push(new Particle(x, y, color, size, speedX, speedY));
            }
        }

        // --- Ø¥Ù†Ø´Ø§Ø¡ ØªØ£Ø«ÙŠØ± Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø§Ù„Ù†Ø§Ø±ÙŠØ© ---
        function createFirework(x, y) {
            const colors = ['#FFD700', '#FF4500', '#ADFF2F', '#00BFFF', '#EE82EE'];
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                const speedX = Math.cos(angle) * speed;
                const speedY = Math.sin(angle) * speed;
                const color = colors[Math.floor(Math.random() * colors.length)];
                particles.push(new Particle(x, y, color, 3, speedX, speedY, 'firework'));
            }
        }
        
        // --- Ø¯ÙˆØ§Ù„ Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ø§Ù„Ù… ÙˆØ§Ù„Ø®Ù„ÙÙŠØ© ---
        function drawBackground() {
            cityOffsetLandmark -= backgroundSpeedLandmark;
            cityOffsetBack -= backgroundSpeedBack;
            cityOffsetFront -= backgroundSpeedFront;
            if (cityOffsetLandmark <= -canvasWidth * 2.5) cityOffsetLandmark = 0;
            if (cityOffsetBack <= -canvasWidth) cityOffsetBack = 0;
            if (cityOffsetFront <= -canvasWidth) cityOffsetFront = 0;

            function drawLandmarkLayer(offset) {
                ctx.fillStyle = '#9DB2BF';
                for (let i = 0; i < 2; i++) {
                    const firstTowerX = offset + i * canvasWidth * 2.5 + canvasWidth * 0.7;
                    drawKingdomTower(firstTowerX, canvasHeight, 90, 330);
                    const secondTowerX = offset + i * canvasWidth * 2.5 + canvasWidth * 1.5;
                    drawFaisaliahTower(secondTowerX, canvasHeight, 70, 290);
                }
            }
            function drawBuildingLayer(offset, color, seed, minHeight, heightRange, layerType) {
                ctx.fillStyle = color;
                for (let i = 0; i < 2; i++) {
                    let currentX = offset + i * canvasWidth;
                    let buildingIndex = 0;
                    while (currentX < offset + (i + 1) * canvasWidth) {
                        const randomizer = Math.abs(Math.sin(buildingIndex * seed));
                        let isLandmark = false;
                        if (layerType === 'front' && buildingIndex > 0 && buildingIndex % 12 === 0) {
                            drawMinaret(currentX, canvasHeight, 20, 90);
                            currentX += 25;
                            isLandmark = true;
                        }
                        if (!isLandmark) {
                            const buildingWidth = (randomizer * 40 + 30) * (canvasWidth / 800);
                            const buildingHeight = (randomizer * heightRange + minHeight) * (canvasHeight / 600);
                            ctx.fillRect(currentX, canvasHeight - buildingHeight, buildingWidth, buildingHeight);
                            const gap = 5;
                            currentX += buildingWidth + gap;
                        }
                        buildingIndex++;
                    }
                }
            }
            drawLandmarkLayer(cityOffsetLandmark);
            drawBuildingLayer(cityOffsetBack, '#6c757d', 0.8, 80, 70, 'back');
            drawBuildingLayer(cityOffsetFront, '#4a4a4a', 0.5, 40, 50, 'front');
        }
        function drawMinaret(x, yBase, width, height) { ctx.fillRect(x, yBase - height, width, height); ctx.fillRect(x - 5, yBase - height, width + 10, 10); ctx.beginPath(); ctx.arc(x + width / 2, yBase - height - 10, width * 0.7, Math.PI, 2 * Math.PI); ctx.fill(); ctx.beginPath(); ctx.arc(x + width / 2, yBase - height - 20, 8, Math.PI * 1.25, Math.PI * 1.75); ctx.stroke(); }
        function drawKingdomTower(x, yBase, width, height) { ctx.beginPath(); ctx.moveTo(x, yBase); ctx.lineTo(x + width, yBase); ctx.lineTo(x + width, yBase - height * 0.8); ctx.arc(x + width / 2, yBase - height * 0.8, width / 2, 0, Math.PI, true); ctx.lineTo(x, yBase - height * 0.8); ctx.closePath(); ctx.fill(); ctx.save(); ctx.globalCompositeOperation = 'destination-out'; ctx.beginPath(); ctx.arc(x + width / 2, yBase - height * 0.85, width / 2.5, 0, 2 * Math.PI); ctx.fill(); ctx.restore(); }
        function drawFaisaliahTower(x, yBase, width, height) { ctx.beginPath(); ctx.moveTo(x, yBase); ctx.lineTo(x + width, yBase); ctx.lineTo(x + width * 0.6, yBase - height); ctx.lineTo(x + width * 0.4, yBase - height); ctx.closePath(); ctx.fill(); ctx.save(); ctx.fillStyle = '#a7c5d4'; ctx.beginPath(); ctx.arc(x + width / 2, yBase - height * 0.7, width * 0.3, 0, 2 * Math.PI); ctx.fill(); ctx.restore(); }
        
        // --- ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„ØµØ­Ø© ---
        function updateHealthDisplay() {
            healthEl.textContent = 'Ø§Ù„ØµØ­Ø©: ' + 'â¤ï¸'.repeat(plane.health > 0 ? plane.health : 0);
        }

        // --- Ø­Ù„Ù‚Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ---
        function animate() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            drawBackground();
            handleParticles(); 
            
            if (!gameOver) {
                handleClouds();
                plane.update();
                plane.draw();
                handleSmoke(); 
                frame++;
            }
            requestAnimationFrame(animate);
        }
        
        // --- Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© ---
        function startGame() {
            if (fireworksInterval) {
                clearInterval(fireworksInterval);
                fireworksInterval = null;
            }
            
            // Hide end-game elements, show start-game elements
            document.getElementById('final-result-display').innerHTML = '';
            document.getElementById('leaderboard-container').innerHTML = '';
            document.getElementById('leaderboard-loader').style.display = 'none';
            document.getElementById('finish-game-wrapper').style.display = 'none';
            messageBox.querySelector('h1').style.display = 'block';
            document.getElementById('welcomeMessage').style.display = 'block';
            document.getElementById('developer-info').style.display = 'block';
            restartButton.textContent = 'Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©';


            gameOver = false;
            score = 0;
            errors = 0; // ** Ø¥Ø¹Ø§Ø¯Ø© ØªØµÙÙŠØ± Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ **
            currentProblemIndex = -1;
            plane.health = 3;
            plane.isExploded = false;
            particles = [];
            frame = 0;
            plane.x = canvasWidth / 5; 
            plane.y = canvasHeight / 2;
            scoreEl.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${toArabicNumerals(score)}`;
            updateHealthDisplay();
            messageBox.style.display = 'none';
            topBar.style.visibility = 'visible';
            statsContainer.style.visibility = 'visible';
            nextProblem();
        }

        // --- Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© ---
        function endGame(isWin = false) {
            gameOver = true;
            
            // Show end-game elements, hide start-game elements
            messageBox.style.display = 'flex';
            messageBox.querySelector('h1').style.display = 'none';
            document.getElementById('welcomeMessage').style.display = 'none';
            document.getElementById('developer-info').style.display = 'none';
            restartButton.textContent = 'Ø§Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰';
            topBar.style.visibility = 'hidden';
            statsContainer.style.visibility = 'hidden';

            // ** Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø¯Ø§Ù„Ø© Ø§Ù„Ø­ÙØ¸ ÙˆØ¹Ø±Ø¶ Ø§Ù„Ø³Ø¬Ù„ **
            saveAndFinishGame(score, errors);
            
            if (isWin && score >= 8) {
                if (fireworksInterval) clearInterval(fireworksInterval);
                fireworksInterval = setInterval(() => {
                    createFirework(Math.random() * canvasWidth, Math.random() * canvasHeight * 0.5);
                }, 500);
            }
        }

        // --- Ø§Ù„ØªØ­ÙƒÙ… ---
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => delete keys[e.key]);
        gameContainer.addEventListener('mousemove', e => {
            if (gameOver) return;
            const rect = canvas.getBoundingClientRect();
            plane.y = e.clientY - rect.top - plane.height / 2;
        });
        gameContainer.addEventListener('touchmove', e => {
            if (gameOver) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            plane.y = e.touches[0].clientY - rect.top - plane.height / 2;
        }, { passive: false });
        
        restartButton.addEventListener('click', startGame);
        
        // --- Ø¨Ø¯Ø¡ Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø³ÙˆÙ…ÙŠØ© ---
        animate();
    </script>
    
    <!-- --- START OF CONNECTION & LEADERBOARD ENGINE --- -->
    <script>
    (function() {
        // --- CONFIGURATION (Ø¹Ø¯Ù‘Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù„ÙƒÙ„ Ù„Ø¹Ø¨Ø©) ---
        const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzrf1-At3Pq7i39bGV3F1iD3-b0G-WWyRi5cgpKeQjyn_N5fh2EmGhoyRKUsbLd-F_UJQ/exec";
        const GAME_ID = 'g3_1_1';
        const GAME_MAX_POINTS = 10;
        const PLATFORM_MAX_GRADE = 5;
        const METRIC_TYPE = 'errors';
        const METRIC_LABEL = 'Ø§Ù„Ø£Ø®Ø·Ø§Ø¡';

        // --- Read URL Parameters ---
        const urlParams = new URLSearchParams(window.location.search);
        const studentId = urlParams.get('studentId');
        const classId = urlParams.get('classId');
        const studentName = urlParams.get('studentName');

        let currentUser = (studentId && studentName) ? { id: studentId, name: studentName } : null;

        // --- CORE FUNCTIONS ---

        // 1. Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø§Ù„ØªÙŠ ØªØ³ØªØ¯Ø¹ÙŠÙ‡Ø§ Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        window.saveAndFinishGame = function(points, metricValue) {
            const finalPoints = parseFloat(points) || 0;
            const finalMetric = parseFloat(metricValue) || 0;
            const maxPoints = parseFloat(GAME_MAX_POINTS) || 1;
            const finalGrade = (finalPoints / maxPoints) * PLATFORM_MAX_GRADE;

            const resultDisplay = document.getElementById('final-result-display');
            if (resultDisplay) {
                resultDisplay.innerHTML = `
                    <p class="text-gray-700">Ø§Ù„Ù†Ù‚Ø§Ø·: <span class="font-bold text-xl">${finalPoints} / ${maxPoints}</span></p>
                    <p class="text-blue-600">Ø§Ù„Ø¯Ø±Ø¬Ø© ÙÙŠ Ø§Ù„Ù…Ù†ØµØ©: <span class="font-bold text-2xl">${finalGrade.toFixed(1)} / ${PLATFORM_MAX_GRADE}</span></p>
                `;
            }

            if (studentId && classId) {
                const params = new URLSearchParams({
                    action: 'saveGrade',
                    studentId: studentId,
                    classId: classId,
                    itemId: GAME_ID,
                    grade: finalGrade.toFixed(2),
                    metricValue: Math.round(finalMetric).toString()
                });
                fetch(`${SCRIPT_URL}?${params.toString()}`)
                    .then(res => res.json())
                    .then(result => console.log('Save result:', result.status))
                    .catch(err => console.error("Save Error:", err))
                    .finally(fetchAndShowLeaderboard);
            } else {
                console.log(`Visitor finished. Score: ${finalPoints}, Metric: ${finalMetric}`);
                fetchAndShowLeaderboard();
            }
        }

        // 2. Ø¯Ø§Ù„Ø© Ø¬Ù„Ø¨ ÙˆØ¹Ø±Ø¶ Ø³Ø¬Ù„ Ø§Ù„Ø£Ø¨Ø·Ø§Ù„
        function fetchAndShowLeaderboard() {
            const loader = document.getElementById('leaderboard-loader');
            const container = document.getElementById('leaderboard-container');
            if (!loader || !container) return;
            
            if (!classId) {
                console.log("No classId found, skipping leaderboard for visitor.");
                container.innerHTML = `<p class="text-center text-gray-500 mt-4">Ø³Ø¬Ù„ Ø§Ù„Ø£Ø¨Ø·Ø§Ù„ Ù…ØªØ§Ø­ Ù„Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…Ø³Ø¬Ù„ÙŠÙ† ÙÙ‚Ø·.</p>`;
                showFinishButton();
                return;
            }

            loader.style.display = 'block';
            container.innerHTML = '';

            const params = new URLSearchParams({
                action: 'getLeaderboard',
                gameId: GAME_ID,
                metricType: METRIC_TYPE,
                classId: classId
            });

            fetch(`${SCRIPT_URL}?${params.toString()}`)
                .then(res => res.json())
                .then(response => {
                    if (response.status === 'success' && response.data) {
                        displayLeaderboard(response.data);
                    } else {
                        throw new Error(response.message || 'Failed to load leaderboard data.');
                    }
                })
                .catch(err => {
                    console.error("Leaderboard Error:", err);
                    container.innerHTML = `<p class="text-center text-red-500">Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø³Ø¬Ù„ Ø§Ù„Ø£Ø¨Ø·Ø§Ù„.</p>`;
                })
                .finally(() => {
                    loader.style.display = 'none';
                    showFinishButton();
                });
        }
        
        // 3. Ø¯Ø§Ù„Ø© Ø¨Ù†Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø³Ø¬Ù„ Ø§Ù„Ø£Ø¨Ø·Ø§Ù„
        function displayLeaderboard(data) {
            const container = document.getElementById('leaderboard-container');
            if (!data || data.length === 0) {
                container.innerHTML = `<p class="text-center text-gray-500 mt-4">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ø¨Ø¹Ø¯. ÙƒÙ† Ø£ÙˆÙ„ Ø§Ù„Ø£Ø¨Ø·Ø§Ù„!</p>`;
                return;
            }

            let tableHTML = `
                <div class="mt-6 border-t pt-4">
                    <h3 class="text-2xl font-bold text-center text-gray-800 mb-4">ğŸ† Ø³Ø¬Ù„ Ø§Ù„Ø£Ø¨Ø·Ø§Ù„ ğŸ†</h3>
                    <table class="min-w-full bg-white shadow-md rounded-lg">
                        <thead class="bg-gray-800 text-white">
                            <tr>
                                <th class="text-center py-2 px-3">Ø§Ù„ØªØ±ØªÙŠØ¨</th>
                                <th class="text-right py-2 px-3">Ø§Ø³Ù… Ø§Ù„Ø·Ø§Ù„Ø¨</th>
                                <th class="text-center py-2 px-3">Ø§Ù„Ø¯Ø±Ø¬Ø©</th>
                                <th class="text-center py-2 px-3">${METRIC_LABEL}</th>
                            </tr>
                        </thead>
                        <tbody class="text-gray-700">`;

            data.forEach((player, index) => {
                const rank = index + 1;
                let rankDisplay = rank;
                if (rank === 1) rankDisplay = 'ğŸ¥‡';
                if (rank === 2) rankDisplay = 'ğŸ¥ˆ';
                if (rank === 3) rankDisplay = 'ğŸ¥‰';

                const isCurrentUser = (currentUser && player.name === currentUser.name);
                const rowClass = isCurrentUser ? 'bg-blue-100 font-bold' : (index % 2 === 0 ? 'bg-gray-100' : '');

                tableHTML += `
                    <tr class="${rowClass}">
                        <td class="text-center py-2 px-3 text-xl">${rankDisplay}</td>
                        <td class="text-right py-2 px-3">${player.name}</td>
                        <td class="text-center py-2 px-3">${player.grade.toFixed(1)}</td>
                        <td class="text-center py-2 px-3">${player.metricValue}</td>
                    </tr>`;
            });

            tableHTML += `</tbody></table></div>`;
            container.innerHTML = tableHTML;
        }

        // 4. Ø¥Ø¸Ù‡Ø§Ø± Ø²Ø± Ø§Ù„Ø¥Ù†Ù‡Ø§Ø¡
        function showFinishButton() {
            const finishWrapper = document.getElementById('finish-game-wrapper');
            if (finishWrapper) {
                finishWrapper.style.display = 'block';
            }
        }

        // 5. Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø²Ø± Ø§Ù„Ø¥Ù†Ù‡Ø§Ø¡ ÙˆØªØ®ØµÙŠØµ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨
        document.addEventListener('DOMContentLoaded', () => {
            // Personalize welcome message
            const welcomeMessage = document.getElementById('welcomeMessage');
            if (studentName && welcomeMessage) {
                // Decode the student's name from URL encoding (e.g., %20 becomes a space)
                const decodedStudentName = decodeURIComponent(studentName);
                welcomeMessage.innerHTML = `Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙŠØ§ <span class="font-bold text-yellow-300">${decodedStudentName}</span>! Ø­Ù„Ù‘Ù‚ Ø¨Ø·Ø§Ø¦Ø±ØªÙƒ Ø¹Ø¨Ø± Ø³Ù…Ø§Ø¡ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª ÙˆØ£Ø¬Ø¨ Ø¹Ù† Ø£Ø³Ø¦Ù„Ø© Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø®Ø· Ø§Ù„Ù…Ø³ØªÙ‚ÙŠÙ… Ù„ØªØµÙ„ Ø¥Ù„Ù‰ ÙˆØ¬Ù‡ØªÙƒ Ø¨Ø³Ù„Ø§Ù….`;
            }

            const finishBtn = document.getElementById('finish-game-btn');
            if (finishBtn) {
                finishBtn.addEventListener('click', () => {
                    window.parent.postMessage({ event: 'gameFinished', gameId: GAME_ID }, '*');
                });
            }
        });
    })();
    // --- END OF CONNECTION & LEADERBOARD ENGINE ---
    </script>
    
</body>
</html>

