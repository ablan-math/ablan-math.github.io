<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>هداف الرياضيات</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: 'Cairo', sans-serif;
            color: white;
            background-color: #1a1a1a;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2vw;
            box-sizing: border-box;
            flex-wrap: wrap;
        }
        .hud-box {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 1vh 2.5vw;
            border-radius: 15px;
            border: 2px solid #FFD700;
            font-size: clamp(0.7em, 1.8vw, 1.3em);
            font-weight: bold;
            margin: 5px;
            flex-shrink: 1;
        }
        @keyframes score-pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.4); color: #4CAF50; }
            100% { transform: scale(1); }
        }
        .score-updated {
            display: inline-block;
            animation: score-pop 0.5s ease-in-out;
        }
        .game-message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(2.8em, 9vw, 7em);
            font-weight: bold;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.6);
            z-index: 200;
            display: none;
            pointer-events: none;
        }
        #goalMessage { color: #FFD700; }
        #saveMessage { color: #f44336; }
        #mathContainer {
            position: absolute;
            bottom: 2vh;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5vh;
            z-index: 100;
        }
        #question {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 1.5vh 4vw;
            border-radius: 15px;
            font-size: clamp(1.6em, 3.5vw, 2.7em);
            font-weight: bold;
            border: 2px solid #fff;
        }
        #question .abs-bars {
            color: #FFD700;
            font-weight: bold;
            margin: 0 5px;
        }
        #optionsContainer {
            display: flex;
            gap: 1vw;
            justify-content: center;
            flex-wrap: wrap;
        }
        .option-button {
            background-color: #2196F3;
            border: 2px solid #fff;
            color: white;
            padding: 1.5vh 4vw;
            text-align: center;
            font-size: clamp(1.1em, 3.2vw, 2em);
            margin: 0.5vh 1vw;
            cursor: pointer;
            border-radius: 12px;
            font-family: 'Cairo', sans-serif;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: background-color 0.3s, transform 0.2s;
        }
        .option-button:hover:not(:disabled) { background-color: #1976D2; transform: scale(1.05); }
        .option-button:disabled { background-color: #9E9E9E; cursor: not-allowed; opacity: 0.6; }
        .correct-answer {
            background-color: #4CAF50 !important;
            border-color: #fff !important;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 300;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2vw;
            box-sizing: border-box;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
            overflow-y: auto; /* Allow scrolling for leaderboard */
        }
        .overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .overlay h2 { font-size: clamp(1.6em, 4.5vw, 2.3em); margin-bottom: 2vh; color: #FFD700; }
        .overlay p { font-size: clamp(0.7em, 2vw, 1em); max-width: 90%; line-height: 1.6; }
        .overlay .start-button {
            margin-top: 3vh;
            padding: 1.5vh 6vw;
            font-size: clamp(1.1em, 3.5vw, 1.8em);
            background-color: #4CAF50;
        }
        .stage-transition h2 {
            transform: scale(0.5);
            opacity: 0;
            animation: pop-in 1s forwards;
        }
        @keyframes pop-in {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        #solutionScreen {
            justify-content: flex-start;
            padding-top: 5vh;
        }
        #solutionContainer {
            background-color: rgba(40, 40, 40, 0.9);
            padding: 2vh;
            border-radius: 20px;
            border: 2px solid #FFD700;
            width: 90%;
            max-width: 900px;
            position: relative;
        }
        #solutionContainer h2 {
            font-size: clamp(1.1em, 3vw, 1.8em);
            margin-bottom: 1vh;
            background-color: #1a1a1a;
            padding: 5px 15px;
            border-radius: 10px;
            position: absolute;
            top: -20px;
            right: 20px;
        }
        #solutionQuestion {
            font-size: clamp(0.9em, 2.8vw, 1.4em);
            margin-top: 3vh;
            margin-bottom: 2vh;
        }
        #solutionSteps {
            min-height: 10vh;
            line-height: 1.8;
            padding: 0 2vw;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .solution-step {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1vh;
            width: 100%;
        }
        .solution-eq {
            font-size: clamp(0.7em, 2.5vw, 1.2em);
            font-weight: bold;
            text-align: right;
            flex-basis: 50%;
        }
        .solution-comment {
            font-size: clamp(0.5em, 1.8vw, 0.9em);
            color: #ccc;
            margin-right: 20px;
            flex-basis: 50%;
            text-align: left;
        }
        .highlight-math {
            color: #4CAF50;
            font-weight: bold;
        }
        #nextStepButton {
            font-size: clamp(0.9em, 2.8vw, 1.4em) !important;
            padding: 1vh 5vw !important;
        }
        #knowWhyButton {
            position: absolute;
            bottom: 3vh;
            right: 3vh;
            font-size: clamp(0.9em, 2.8vw, 1.4em);
            background-color: #ff9800;
            visibility: hidden;
            z-index: 101;
        }
        #timerDisplay {
            transition: color 0.5s, transform 0.2s;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        #timerDisplay.warning {
            color: #f44336;
            animation: shake 0.5s infinite;
        }
        @keyframes screen-shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .screen-shake {
            animation: screen-shake 0.5s;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Leaderboard Styles */
        #finalScoreScreen {
            color: #333;
            padding: 20px;
            box-sizing: border-box;
        }
        #finalScoreScreen .content-wrapper {
             background-color: rgba(255, 255, 255, 0.95);
             padding: 20px;
             border-radius: 15px;
             max-width: 600px;
             width: 90%;
             max-height: 90vh;
             overflow-y: auto;
        }
        #leaderboard-container table {
            width: 100%;
            border-collapse: collapse;
        }
        #leaderboard-container th, #leaderboard-container td {
            padding: 8px 12px;
            border: 1px solid #ddd;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
</head>
<body>

    <div id="info" style="visibility: hidden;">
        <div id="timerDisplay" class="hud-box">الوقت: <span id="timerValue">٢٥</span></div>
        <div id="totalTimeDisplay" class="hud-box">الوقت الكلي: <span id="totalTimeValue">٠</span></div>
        <div id="stageInfo" class="hud-box">المرحلة ١ - السؤال ١ / ٥</div>
        <div id="scoreDisplay" class="hud-box">النتيجة: <span id="scoreValue">٠</span></div>
    </div>

    <div id="goalMessage" class="game-message">هدف</div>
    <div id="saveMessage" class="game-message">ضائعة</div>
    <div id="mathContainer" style="visibility: hidden;">
        <div id="question"></div>
        <div id="optionsContainer"></div>
    </div>
    <button id="knowWhyButton" class="option-button">اعرف لماذا؟</button>

    <div id="welcomeScreen" class="overlay visible">
        <h2>أهلاً بك في لعبة هداف الرياضيات</h2>
        <p>تصميم وبرمجة / أ. عبالعزيز خالد العبلان</p>
        <p id="welcomeMessage" style="color: #FFD700; font-size: 1.2em; margin: 20px 0;"><strong>طريقة اللعب:</strong> أجب عن المسألة بشكل صحيح لتسديد الكرة وتسجيل هدف. إذا كانت إجابتك خاطئة، سيتصدى الحارس للكرة!</p>
        <button id="startButton" class="option-button start-button">ابدأ اللعب</button>
    </div>

    <div id="stageTransitionScreen" class="overlay stage-transition">
        <h2 id="stageTransitionText"></h2>
    </div>

    <div id="finalScoreScreen" class="overlay">
        <div class="content-wrapper">
            <h2>انتهت اللعبة!</h2>
            <p id="feedbackText" style="font-size: 1.2em;"></p>
            
            <!-- 1. لعرض نتيجة الطالب الحالية -->
            <div id="final-result-display" class="text-center text-xl mt-4"></div>

            <!-- 2. لعرض أيقونة التحميل -->
            <div id="leaderboard-loader" style="display: none;" class="text-center mt-6">
                <div style="margin:auto; border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 2s linear infinite;"></div>
                <p>جاري تحميل سجل الأبطال...</p>
            </div>

            <!-- 3. لعرض جدول سجل الأبطال -->
            <div id="leaderboard-container" class="mt-4"></div>

            <!-- 4. زر لإنهاء اللعبة والعودة للمنصة (جديد) -->
            <div id="finish-game-wrapper" class="text-center mt-6" style="display: none;">
                <button id="finish-game-btn" class="option-button" style="background-color: #f44336;">
                    إنهاء والعودة للمنصة
                </button>
            </div>
             <button id="playAgainButton" class="option-button start-button">العب مرة أخرى</button>
        </div>
    </div>

    <div id="solutionScreen" class="overlay">
        <div id="solutionContainer">
            <h2>طريقة الحل</h2>
            <p id="solutionQuestion"></p>
            <div id="solutionSteps"></div>
            <button id="nextStepButton" class="option-button">التالي</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let ball, ballVelocity, isBallShot = false, goalScored = false;
        let keeperGroup, keeperTarget, isKeeperReacting = false, keeperSaved = false;
        let leftArm, rightArm, initialLeftArmRot, initialRightArmRot;
        let net, originalNetVertices;
        let collisionAura, auraBoundingBox;
        let leftPost, rightPost, crossbar;
        let flags = []; // Array to hold flags for animation
        
        let goalMessageElement, saveMessageElement;
        let questionElement, optionsContainer, stageInfoElement, scoreDisplayElement, scoreValueElement;
        let welcomeScreen, startButton, stageTransitionScreen, stageTransitionText, finalScoreScreen, playAgainButton, feedbackText;
        let infoContainer, mathContainer, knowWhyButton;
        let solutionScreen, solutionContainer, solutionQuestion, solutionSteps, nextStepButton;
        let timerDisplay, timerValueElement, totalTimeValueElement;
        
        let currentStage = 1;
        let questionIndex = 0;
        const problemsPerStage = [5, 5];
        let currentProblem = {};
        let shotTypeGlobal = '';
        let hasHitNet = false;
        let score = 0;
        let solutionStepsArray = [];
        let currentStepIndex = 0;
        let timerInterval, gameTimerInterval;
        let timeLeft = 25;
        const TIME_PER_QUESTION = 25;
        let resetTimeoutId = null;
        let isResetting = false;
        let confettiGroup, confettiParticles = [];
        let stage1ProblemTypes = [];

        let initialKeeperPosition = new THREE.Vector3();
        let totalTimeSpent = 0;

        const ballRadius = 0.15;
        const gravity = new THREE.Vector3(0, -0.015, 0);
        const goalLineZ = 0.5;
        const goalWidth = 7.32;
        const goalHeight = 2.44;
        const netDepth = 2;
        const postRadius = 0.08;
        
        const crowdCheer = new Tone.NoiseSynth({
            noise: { type: 'pink' },
            envelope: { attack: 0.2, decay: 1.5, sustain: 0, release: 1 }
        }).toDestination();
        crowdCheer.volume.value = -12;

        const netSound = new Tone.NoiseSynth({
            noise: { type: 'white' },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0 }
        }).toDestination();
        netSound.volume.value = -6;

        const saveSound = new Tone.MembraneSynth({
            pitchDecay: 0.08,
            octaves: 4,
            envelope: { attack: 0.001, decay: 0.3, sustain: 0.01, release: 0.5 }
        }).toDestination();
        saveSound.volume.value = -6;

        const whistle = new Tone.Synth({
            oscillator: { type: 'triangle' },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 }
        }).toDestination();
        const vibrato = new Tone.LFO("20hz", 400, 450).start();
        vibrato.connect(whistle.frequency);

        const excellentFeedback = [
            "رائع! أنت نجم الرياضيات، فهمك للقيمة المطلقة ممتاز.",
            "عمل مذهل! لقد أتقنت المهارة، استمر في هذا التفوق.",
            "أحسنت! نتيجتك تدل على تركيز وفهم عميق للدرس."
        ];
        const goodFeedback = [
            "جيد جدًا! أنت على الطريق الصحيح لفهم القيمة المطلقة بشكل كامل.",
            "عمل رائع! بعض الأخطاء البسيطة لا تقلل من مجهودك. حاول مرة أخرى للوصول للعلامة الكاملة.",
            "أحسنت! لقد فهمت الفكرة الأساسية، والقليل من المراجعة سيجعلك محترفًا."
        ];
        const needsImprovementFeedback = [
            "بداية جيدة! كل خطأ هو فرصة للتعلم. استخدم زر 'اعرف لماذا؟' لمراجعة الحلول.",
            "لا تستسلم! القيمة المطلقة تحتاج للقليل من التدريب. أنا واثق أنك ستتقنها في المرة القادمة.",
            "مجهود طيب! حاول التركيز على ترتيب العمليات، وستجد أن المسائل أصبحت أسهل."
        ];
        const lowFeedback = [
            "للاسف مستواك ضعيف ! ومع ذلك كل خطأ هو فرصة للتعلم. استخدم زر 'اعرف لماذا؟' لمراجعة الحلول.",
            "لا تستسلم! القيمة المطلقة تحتاج للكثير من التدريب. أنا واثق أنك ستتقنها في المرة القادمة.",
            "حاول مرة اخرى ! حاول التركيز على ترتيب العمليات، وستجد أن المسائل أصبحت أسهل."
        ];


        function init() {
            goalMessageElement = document.getElementById('goalMessage');
            saveMessageElement = document.getElementById('saveMessage');
            questionElement = document.getElementById('question');
            optionsContainer = document.getElementById('optionsContainer');
            stageInfoElement = document.getElementById('stageInfo');
            scoreDisplayElement = document.getElementById('scoreDisplay');
            scoreValueElement = document.getElementById('scoreValue');
            welcomeScreen = document.getElementById('welcomeScreen');
            startButton = document.getElementById('startButton');
            stageTransitionScreen = document.getElementById('stageTransitionScreen');
            stageTransitionText = document.getElementById('stageTransitionText');
            finalScoreScreen = document.getElementById('finalScoreScreen');
            playAgainButton = document.getElementById('playAgainButton');
            feedbackText = document.getElementById('feedbackText');
            infoContainer = document.getElementById('info');
            mathContainer = document.getElementById('mathContainer');
            knowWhyButton = document.getElementById('knowWhyButton');
            solutionScreen = document.getElementById('solutionScreen');
            solutionContainer = document.getElementById('solutionContainer');
            solutionQuestion = document.getElementById('solutionQuestion');
            solutionSteps = document.getElementById('solutionSteps');
            nextStepButton = document.getElementById('nextStepButton');
            timerDisplay = document.getElementById('timerDisplay');
            timerValueElement = document.getElementById('timerValue');
            totalTimeValueElement = document.getElementById('totalTimeValue');
            
            startButton.addEventListener('click', startGame);
            playAgainButton.addEventListener('click', restartGame);
            knowWhyButton.addEventListener('click', showSolution);
            nextStepButton.addEventListener('click', showNextSolutionStep);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 20, 80);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 4, 12);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 2, 0);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            createFieldAndGoal();
            createStadium();
            createGoalkeeper();
            createBall();
            
            confettiGroup = new THREE.Group();
            scene.add(confettiGroup);
            
            window.addEventListener('resize', onWindowResize);
            animate();
        }
        
        function createFieldAndGoal() {
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });

            const penaltyBoxWidth = 18;
            const penaltyBoxDepth = 8;
            const penaltyPoints = [
                new THREE.Vector3(-penaltyBoxWidth / 2, 0.01, 0.5),
                new THREE.Vector3(penaltyBoxWidth / 2, 0.01, 0.5),
                new THREE.Vector3(penaltyBoxWidth / 2, 0.01, 0.5 + penaltyBoxDepth),
                new THREE.Vector3(-penaltyBoxWidth / 2, 0.01, 0.5 + penaltyBoxDepth),
                new THREE.Vector3(-penaltyBoxWidth / 2, 0.01, 0.5)
            ];
            const penaltyGeometry = new THREE.BufferGeometry().setFromPoints(penaltyPoints);
            const penaltyLine = new THREE.Line(penaltyGeometry, lineMaterial);
            scene.add(penaltyLine);

            const fieldWidth = 44;
            const fieldDepth = 60;
            const fieldPoints = [
                 new THREE.Vector3(-fieldWidth / 2, 0.01, 0.5),
                 new THREE.Vector3(fieldWidth / 2, 0.01, 0.5),
                 new THREE.Vector3(fieldWidth / 2, 0.01, fieldDepth),
                 new THREE.Vector3(-fieldWidth / 2, 0.01, fieldDepth),
                 new THREE.Vector3(-fieldWidth / 2, 0.01, 0.5)
            ];
            const fieldGeometry = new THREE.BufferGeometry().setFromPoints(fieldPoints);
            const fieldLines = new THREE.Line(fieldGeometry, lineMaterial);
            scene.add(fieldLines);


            const goalMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.2, roughness: 0.1 });
            leftPost = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalHeight, 32), goalMaterial);
            leftPost.position.set(-goalWidth / 2, goalHeight / 2, 0);
            leftPost.castShadow = true;
            scene.add(leftPost);
            rightPost = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalHeight, 32), goalMaterial);
            rightPost.position.set(goalWidth / 2, goalHeight / 2, 0);
            rightPost.castShadow = true;
            scene.add(rightPost);
            crossbar = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalWidth, 32), goalMaterial);
            crossbar.position.set(0, goalHeight, 0);
            crossbar.rotation.z = Math.PI / 2;
            crossbar.castShadow = true;
            scene.add(crossbar);

            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            context.lineWidth = 5;
            context.strokeRect(0, 0, 64, 64);
            const netTexture = new THREE.CanvasTexture(canvas);
            netTexture.wrapS = THREE.RepeatWrapping;
            netTexture.wrapT = THREE.RepeatWrapping;
            
            const netMaterial = new THREE.MeshBasicMaterial({
                map: netTexture,
                transparent: true,
                side: THREE.DoubleSide,
                alphaTest: 0.1
            });

            const netGeometry = new THREE.PlaneGeometry(goalWidth, goalHeight, 20, 10);
            originalNetVertices = netGeometry.attributes.position.array.slice();
            net = new THREE.Mesh(netGeometry, netMaterial);
            net.position.set(0, goalHeight / 2, -netDepth);
            netTexture.repeat.set(15, 5);
            scene.add(net);
            
            const topNetGeometry = new THREE.PlaneGeometry(goalWidth, netDepth, 20, 5);
            const topNet = new THREE.Mesh(topNetGeometry, netMaterial.clone());
            topNet.material.map = netTexture.clone();
            topNet.material.map.repeat.set(15, 2);
            topNet.rotation.x = -Math.PI / 2;
            topNet.position.set(0, goalHeight, -netDepth / 2);
            scene.add(topNet);

            const sideNetGeometry = new THREE.PlaneGeometry(netDepth, goalHeight, 5, 10);
            const leftNet = new THREE.Mesh(sideNetGeometry, netMaterial.clone());
            leftNet.material.map = netTexture.clone();
            leftNet.material.map.repeat.set(2, 5);
            leftNet.rotation.y = Math.PI / 2;
            leftNet.position.set(-goalWidth / 2, goalHeight / 2, -netDepth / 2);
            scene.add(leftNet);

            const rightNet = new THREE.Mesh(sideNetGeometry, netMaterial.clone());
            rightNet.material.map = netTexture.clone();
            rightNet.material.map.repeat.set(2, 5);
            rightNet.rotation.y = -Math.PI / 2;
            rightNet.position.set(goalWidth / 2, goalHeight / 2, -netDepth / 2);
            scene.add(rightNet);
        }

        function createStadium() {
            const stadiumGroup = new THREE.Group();
            stadiumGroup.position.z = -15; 
            stadiumGroup.rotation.y = Math.PI;
            scene.add(stadiumGroup);

            const standMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.8 });
            const numTiers = 8;
            const tierHeight = 1.5;
            const tierDepth = 2.5;
            const standWidth = 50;

            for (let i = 0; i < numTiers; i++) {
                const tierGeometry = new THREE.BoxGeometry(standWidth, tierHeight, tierDepth);
                const tier = new THREE.Mesh(tierGeometry, standMaterial);
                tier.position.y = (i * tierHeight / 2) + (tierHeight / 2);
                tier.position.z = i * tierDepth * 0.8;
                tier.receiveShadow = true;
                stadiumGroup.add(tier);

                const spectatorColors = [0xff0000, 0x0000ff, 0xffffff, 0xffff00];
                const numSpectators = 150;
                for (let j = 0; j < numSpectators; j++) {
                    const spectatorGeom = new THREE.SphereGeometry(0.3, 8, 6);
                    const spectatorMat = new THREE.MeshStandardMaterial({
                        color: spectatorColors[Math.floor(Math.random() * spectatorColors.length)],
                        roughness: 1
                    });
                    const spectator = new THREE.Mesh(spectatorGeom, spectatorMat);
                    spectator.position.set(
                        THREE.MathUtils.randFloat(-standWidth / 2.1, standWidth / 2.1),
                        tier.position.y + tierHeight / 2 + 0.3,
                        tier.position.z + THREE.MathUtils.randFloat(-tierDepth / 2.2, tierDepth / 2.2)
                    );
                    stadiumGroup.add(spectator);
                }
            }
            
            const numFlags = 6;
            for (let i = 0; i < numFlags; i++) {
                const flagGroup = new THREE.Group();
                const poleGeom = new THREE.CylinderGeometry(0.1, 0.1, 8, 8);
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
                const pole = new THREE.Mesh(poleGeom, poleMat);
                
                const flagGeom = new THREE.PlaneGeometry(2, 1.2, 10, 5);
                const flagMat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xff0000 : 0x0000ff, side: THREE.DoubleSide });
                const flag = new THREE.Mesh(flagGeom, flagMat);
                flag.position.set(1, 3, 0);
                flag.userData.originalVertices = flag.geometry.attributes.position.array.slice();

                flagGroup.add(pole);
                flagGroup.add(flag);
                
                flagGroup.position.set(
                    -standWidth/2 + (i * standWidth / (numFlags - 1)),
                    numTiers * tierHeight / 2 + 4,
                    numTiers * tierDepth * 0.8
                );
                stadiumGroup.add(flagGroup);
                flags.push(flag);
            }
        }

        function createGoalkeeper() {
            keeperGroup = new THREE.Group();
            keeperGroup.position.set(0, 0, goalLineZ);
            initialKeeperPosition.copy(keeperGroup.position);
            keeperTarget = new THREE.Vector3();
            scene.add(keeperGroup);

            const torsoMaterial = new THREE.MeshStandardMaterial({ color: 0xff8c00 });
            const shortsMaterial = new THREE.MeshStandardMaterial({ color: 0x1e1e1e });
            const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xDEB887 });
            const glovesMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });

            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.3), torsoMaterial);
            torso.position.y = 1;
            keeperGroup.add(torso);
            
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), skinMaterial);
            head.position.y = 1.55;
            keeperGroup.add(head);

            const pelvis = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.3), shortsMaterial);
            pelvis.position.y = 0.55;
            keeperGroup.add(pelvis);
            
            const legAngle = -0.2;
            const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.08, 0.9), shortsMaterial);
            rightLeg.position.set(-0.15, 0.1, 0);
            rightLeg.rotation.z = -legAngle;
            keeperGroup.add(rightLeg);
            
            const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.08, 0.9), shortsMaterial);
            leftLeg.position.set(0.15, 0.1, 0);
            leftLeg.rotation.z = legAngle;
            keeperGroup.add(leftLeg);

            const armLength = 0.6;
            rightArm = new THREE.Object3D();
            rightArm.position.set(-0.25, 0.3, 0);
            torso.add(rightArm);
            const rightArmMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.06, armLength), torsoMaterial);
            rightArmMesh.position.y = -armLength / 2;
            rightArm.add(rightArmMesh);
            const rightGlove = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), glovesMaterial);
            rightGlove.position.y = -armLength / 2;
            rightArmMesh.add(rightGlove);

            leftArm = new THREE.Object3D();
            leftArm.position.set(0.25, 0.3, 0);
            torso.add(leftArm);
            const leftArmMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.06, armLength), torsoMaterial);
            leftArmMesh.position.y = -armLength / 2;
            leftArm.add(leftArmMesh);
            const leftGlove = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), glovesMaterial);
            leftGlove.position.y = -armLength / 2;
            leftArmMesh.add(leftGlove);

            const armAngle = 1.2;
            rightArm.rotation.z = -armAngle;
            leftArm.rotation.z = armAngle;

            initialLeftArmRot = leftArm.rotation.clone();
            initialRightArmRot = rightArm.rotation.clone();

            const auraGeometry = new THREE.BoxGeometry(2.5, 2.5, 0.5);
            const auraMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.0 });
            collisionAura = new THREE.Mesh(auraGeometry, auraMaterial);
            collisionAura.position.y = 1; 
            keeperGroup.add(collisionAura);
            auraBoundingBox = new THREE.Box3().setFromObject(collisionAura);
        }

        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            context.fillStyle = '#FFFFFF';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#000000';
            function drawHexagon(x, y, size) {
                context.beginPath();
                for (let i = 0; i < 6; i++) {
                    context.lineTo(x + size * Math.cos(i * Math.PI / 3), y + size * Math.sin(i * Math.PI / 3));
                }
                context.closePath();
                context.fill();
            }
            drawHexagon(64, 40, 22);
            drawHexagon(192, 40, 22);
            drawHexagon(128, 95, 22);
            drawHexagon(250, 95, 22);
            drawHexagon(6, 95, 22);
            const ballTexture = new THREE.CanvasTexture(canvas);
            const ballMaterial = new THREE.MeshStandardMaterial({ map: ballTexture, metalness: 0.1, roughness: 0.5 });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.castShadow = true;
            ball.receiveShadow = true;
            ballVelocity = new THREE.Vector3();
            resetGame(true);
            scene.add(ball);
        }

        async function startGame() {
            await Tone.start();
            welcomeScreen.classList.remove('visible');
            showStageIntro(1);
        }

        function restartGame() {
            finalScoreScreen.classList.remove('visible');
            stopGameTimer();
            totalTimeSpent = 0;
            updateTotalTimeDisplay();
            showStageIntro(1);
        }

        function showStageIntro(stage) {
            stageTransitionText.innerText = `المرحلة ${toArabicNumerals(stage)}`;
            stageTransitionScreen.classList.add('visible');
            setTimeout(() => {
                stageTransitionScreen.classList.remove('visible');
                infoContainer.style.visibility = 'visible';
                mathContainer.style.visibility = 'visible';
                if (stage === 1) {
                    startGameTimer();
                }
                startStage(stage);
            }, 2500);
        }

        function startStage(stage) {
            currentStage = stage;
            questionIndex = 0;
            if (stage === 1) {
                score = 0;
                stage1ProblemTypes = ['abs_negative', 'subtraction', 'subtraction', 'subtraction', 'subtraction'];
                stage1ProblemTypes.sort(() => Math.random() - 0.5);
            }
            updateScoreDisplay(true);
            displayNewQuestion();
        }

        function toArabicNumerals(num) {
            const arabicNumerals = ['٠', '١', '٢', '٣', '٤', '٥', '٦', '٧', '٨', '٩'];
            const sign = num < 0 ? '−' : '';
            const numStr = String(Math.abs(num));
            return sign + numStr.replace(/[0-9]/g, d => arabicNumerals[parseInt(d)]);
        }

        function displayNewQuestion() {
            stageInfoElement.innerText = `المرحلة ${toArabicNumerals(currentStage)} - السؤال ${toArabicNumerals(questionIndex + 1)} / ${toArabicNumerals(problemsPerStage[currentStage - 1])}`;
            currentProblem = generateProblem(currentStage);
            questionElement.innerHTML = currentProblem.html;

            const options = generateOptions(currentProblem.answer);
            optionsContainer.innerHTML = '';
            options.forEach(option => {
                const button = document.createElement('button');
                button.className = 'option-button';
                button.innerText = toArabicNumerals(option);
                button.onclick = () => checkAnswer(option);
                optionsContainer.appendChild(button);
            });
            startTimer();
            whistle.triggerAttackRelease("A5", "0.3");
        }
        
        function generateProblem(stage) {
            let num1, num2, num3, num4;
            let html, answer, steps;

            if (stage === 1) {
                const problemType = stage1ProblemTypes[questionIndex];
                if (problemType === 'subtraction') { 
                    num1 = Math.floor(Math.random() * 20) + 1;
                    num2 = Math.floor(Math.random() * 20) + 1;
                    html = `<span class="abs-bars">|</span> ${toArabicNumerals(num1)} - ${toArabicNumerals(num2)} <span class="abs-bars">|</span>`;
                    answer = Math.abs(num1 - num2);
                    steps = [
                        { eq: `<span class="abs-bars">|</span> <span class="highlight-math">${toArabicNumerals(num1)} - ${toArabicNumerals(num2)}</span> <span class="abs-bars">|</span>`, comment: "نحل ما بداخل القيمة المطلقة" },
                        { eq: `<span class="abs-bars">|</span> <span class="highlight-math">${toArabicNumerals(num1 - num2)}</span> <span class="abs-bars">|</span>`, comment: "نوجد القيمة المطلقة" },
                        { eq: `<span class="highlight-math">${toArabicNumerals(answer)}</span>`, comment: "النتيجة النهائية" }
                    ];
                } else { 
                    num1 = -(Math.floor(Math.random() * 20) + 1);
                    html = `<span class="abs-bars">|</span> ${toArabicNumerals(num1)} <span class="abs-bars">|</span>`;
                    answer = Math.abs(num1);
                    steps = [
                        { eq: `<span class="abs-bars">|</span> <span class="highlight-math">${toArabicNumerals(num1)}</span> <span class="abs-bars">|</span>`, comment: "القيمة المطلقة لعدد سالب هي نظيره الموجب" },
                        { eq: `<span class="highlight-math">${toArabicNumerals(answer)}</span>`, comment: "النتيجة النهائية" }
                    ];
                }
            } else { 
                const problemType = Math.random();
                if (problemType < 0.33) { 
                    num1 = Math.floor(Math.random() * 9) + 1;
                    num2 = Math.floor(Math.random() * 9) + 1;
                    num3 = Math.floor(Math.random() * 9) + 1;
                    html = `<span class="abs-bars">|</span> ${toArabicNumerals(num1)} - ${toArabicNumerals(num2)} <span class="abs-bars">|</span> + ${toArabicNumerals(num3)}`;
                    answer = Math.abs(num1 - num2) + num3;
                        steps = [
                        { eq: `<span class="abs-bars">|</span> <span class="highlight-math">${toArabicNumerals(num1)} - ${toArabicNumerals(num2)}</span> <span class="abs-bars">|</span> + ${toArabicNumerals(num3)}`, comment: "نبدأ بالقيمة المطلقة" },
                        { eq: `<span class="highlight-math">${toArabicNumerals(Math.abs(num1 - num2))}</span> + ${toArabicNumerals(num3)}`, comment: "ثم نجمع" },
                        { eq: `<span class="highlight-math">${toArabicNumerals(answer)}</span>`, comment: "النتيجة النهائية" }
                    ];
                } else if (problemType < 0.66) { 
                    num3 = Math.floor(Math.random() * 9) + 1; 
                    num4 = Math.floor(Math.random() * 9) + 1;
                    num2 = Math.floor(Math.random() * 4) + 1;
                    const product = num2 * Math.abs(num3 - num4);
                    num1 = Math.floor(Math.random() * (product + 10)); 
                    html = `${toArabicNumerals(num1)} - ${toArabicNumerals(num2)} × <span class="abs-bars">|</span> ${toArabicNumerals(num3)} - ${toArabicNumerals(num4)} <span class="abs-bars">|</span>`;
                    answer = num1 - product;
                    steps = [
                        { eq: `${toArabicNumerals(num1)} - ${toArabicNumerals(num2)} × <span class="abs-bars">|</span> <span class="highlight-math">${toArabicNumerals(num3)} - ${toArabicNumerals(num4)}</span> <span class="abs-bars">|</span>`, comment: "نبدأ بالقيمة المطلقة" },
                        { eq: `${toArabicNumerals(num1)} - <span class="highlight-math">${toArabicNumerals(num2)} × ${toArabicNumerals(Math.abs(num3 - num4))}</span>`, comment: "ثم نقوم بالضرب" },
                        { eq: `<span class="highlight-math">${toArabicNumerals(num1)} - ${toArabicNumerals(product)}</span>`, comment: "أخيرًا نطرح" },
                        { eq: `<span class="highlight-math">${toArabicNumerals(answer)}</span>`, comment: "النتيجة النهائية" }
                    ];
                } else {
                    num1 = Math.floor(Math.random() * 9) + 1;
                    num2 = Math.floor(Math.random() * 9) + 1;
                    num3 = Math.floor(Math.random() * 15) + 5;
                    html = `<span class="abs-bars">|</span> ${toArabicNumerals(num1)} + ${toArabicNumerals(num2)} <span class="abs-bars">|</span> - ${toArabicNumerals(num3)}`;
                    answer = Math.abs(num1 + num2) - num3;
                    steps = [
                        { eq: `<span class="abs-bars">|</span> <span class="highlight-math">${toArabicNumerals(num1)} + ${toArabicNumerals(num2)}</span> <span class="abs-bars">|</span> - ${toArabicNumerals(num3)}`, comment: "نبدأ بالقيمة المطلقة" },
                        { eq: `<span class="highlight-math">${toArabicNumerals(Math.abs(num1 + num2))}</span> - ${toArabicNumerals(num3)}`, comment: "ثم نطرح" },
                        { eq: `<span class="highlight-math">${toArabicNumerals(answer)}</span>`, comment: "النتيجة النهائية" }
                    ];
                }
            }
            return { html, answer, steps };
        }

        function generateOptions(correctAnswer) {
            let options = [correctAnswer];
            while (options.length < 4) {
                let wrongAnswer;
                const offset = Math.floor(Math.random() * 5) + 1;
                if (Math.random() < 0.5) {
                    wrongAnswer = correctAnswer + offset;
                } else {
                    wrongAnswer = correctAnswer - offset;
                }
                if (!options.includes(wrongAnswer)) {
                    options.push(wrongAnswer);
                }
            }
            return options.sort(() => Math.random() - 0.5);
        }

        function checkAnswer(selectedAnswer) {
            stopTimer();
            document.querySelectorAll('#optionsContainer .option-button').forEach(b => b.disabled = true);
            knowWhyButton.style.visibility = 'visible';

            if (selectedAnswer === currentProblem.answer) {
                score++;
                updateScoreDisplay();
                shootBall('goal');
                goalMessageElement.style.display = 'block';
            } else {
                shootBall('save');
                saveMessageElement.style.display = 'block';
                document.querySelectorAll('#optionsContainer .option-button').forEach(b => {
                    if (parseInt(b.innerText.replace(/[٠-٩]/g, d => '٠١٢٣٤٥٦٧٨٩'.indexOf(d))) === currentProblem.answer) {
                        b.classList.add('correct-answer');
                    }
                });
            }
        }

        function showSolution() {
            clearTimeout(resetTimeoutId);
            resetTimeoutId = null;
            solutionQuestion.innerHTML = currentProblem.html;
            solutionStepsArray = currentProblem.steps;
            currentStepIndex = 0;
            solutionSteps.innerHTML = '';
            nextStepButton.innerText = 'التالي';
            showNextSolutionStep();
            solutionScreen.classList.add('visible');
        }

        function showNextSolutionStep() {
            if (currentStepIndex < solutionStepsArray.length) {
                const step = solutionStepsArray[currentStepIndex];
                const stepDiv = document.createElement('div');
                stepDiv.className = 'solution-step';
                stepDiv.innerHTML = `<span class="solution-eq">${step.eq}</span><span class="solution-comment">${step.comment}</span>`;
                solutionSteps.appendChild(stepDiv);
                currentStepIndex++;
                if (currentStepIndex === solutionStepsArray.length) {
                    nextStepButton.innerText = 'إغلاق';
                }
            } else {
                solutionScreen.classList.remove('visible');
                setTimeout(() => resetGame(false), 500);
            }
        }

        function updateScoreDisplay(isReset = false) {
            scoreValueElement.innerText = toArabicNumerals(score);
            if (!isReset) {
                scoreValueElement.classList.add('score-updated');
                setTimeout(() => {
                    scoreValueElement.classList.remove('score-updated');
                }, 500);
            }
        }

        function startTimer() {
            timeLeft = TIME_PER_QUESTION;
            timerValueElement.innerText = toArabicNumerals(timeLeft);
            timerDisplay.classList.remove('warning');

            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timeLeft--;
                timerValueElement.innerText = toArabicNumerals(timeLeft);
                if (timeLeft <= 5) {
                    timerDisplay.classList.add('warning');
                }
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    checkAnswer(null);
                }
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function startGameTimer() {
            stopGameTimer(); // Ensure no multiple timers
            gameTimerInterval = setInterval(() => {
                totalTimeSpent++;
                updateTotalTimeDisplay();
            }, 1000);
        }

        function stopGameTimer() {
            clearInterval(gameTimerInterval);
        }

        function updateTotalTimeDisplay() {
            if (totalTimeValueElement) {
                totalTimeValueElement.innerText = toArabicNumerals(Math.round(totalTimeSpent));
            }
        }

        function shootBall(type) {
            if (isBallShot) return;
            isBallShot = true;
            isKeeperReacting = true;
            shotTypeGlobal = type;
            
            let shotTarget = new THREE.Vector3();

            if (type === 'goal') {
                const goalSide = Math.random() < 0.5 ? -1 : 1;
                shotTarget.set((goalWidth / 2 * 0.8) * goalSide, goalHeight * 0.8, goalLineZ - 0.5);
                keeperTarget.set(shotTarget.x * -1, shotTarget.y, goalLineZ);
                ballVelocity = shotTarget.clone().sub(ball.position).normalize().multiplyScalar(0.75);
                triggerGoalEffects();
            } else { // 'save'
                const diveX = THREE.MathUtils.randFloat(-2.0, 2.0);
                const diveY = THREE.MathUtils.randFloat(0.5, 1.8);
                keeperTarget.set(diveX, diveY, goalLineZ);
                shotTarget.copy(keeperTarget).y += 0.2;
                ballVelocity = shotTarget.clone().sub(ball.position).normalize().multiplyScalar(0.6);
            }
        }

        function resetGame(isInitial = false) {
            clearTimeout(resetTimeoutId);
            resetTimeoutId = null;
            isResetting = false;

            if (goalMessageElement) goalMessageElement.style.display = 'none';
            if (saveMessageElement) saveMessageElement.style.display = 'none';

            isBallShot = false;
            isKeeperReacting = false;
            keeperSaved = false;
            goalScored = false;
            hasHitNet = false;
            ball.position.set(0, ballRadius, 7);
            ballVelocity.set(0, 0, 0);
            keeperGroup.position.copy(initialKeeperPosition);
            knowWhyButton.style.visibility = 'hidden';
            
            if (!isInitial) {
                questionIndex++;
                if (questionIndex >= problemsPerStage[currentStage - 1]) {
                    if (currentStage < 2) {
                        infoContainer.style.visibility = 'hidden';
                        mathContainer.style.visibility = 'hidden';
                        showStageIntro(2);
                    } else {
                        showFinalScore();
                    }
                } else {
                    displayNewQuestion();
                }
            }
        }

        function showFinalScore() {
            infoContainer.style.visibility = 'hidden';
            mathContainer.style.visibility = 'hidden';
            stopGameTimer();
            
            let feedback = '';
            if (score >= 9) {
                feedback = excellentFeedback[Math.floor(Math.random() * excellentFeedback.length)];
            } else if (score >= 6) {
                feedback = goodFeedback[Math.floor(Math.random() * goodFeedback.length)];
            } else if (score >= 3) {
                feedback = needsImprovementFeedback[Math.floor(Math.random() * needsImprovementFeedback.length)];
            } else {
                feedback = lowFeedback[Math.floor(Math.random() * lowFeedback.length)];
            }
            feedbackText.innerText = feedback;
            
            finalScoreScreen.classList.add('visible');
            saveAndFinishGame(score, Math.round(totalTimeSpent));
        }

        function handleCollision() {
            saveSound.triggerAttackRelease("C2", "0.5");
            keeperSaved = true;
            isKeeperReacting = false;
            const reboundDirection = new THREE.Vector3(
                THREE.MathUtils.randFloat(-1, 1),
                THREE.MathUtils.randFloat(0.5, 1.2),
                THREE.MathUtils.randFloat(0.8, 1.5)
            );
            reboundDirection.normalize();
            ballVelocity.copy(reboundDirection).multiplyScalar(0.8);
        }
        
        function triggerGoalEffects() {
            document.body.classList.add('screen-shake');
            setTimeout(() => document.body.classList.remove('screen-shake'), 500);
            flashGoalposts();
            createConfetti();
            crowdCheer.triggerAttackRelease("2.5s");
        }

        function flashGoalposts() {
            const posts = [leftPost, rightPost, crossbar];
            const originalEmissive = posts[0].material.emissive.getHex();
            
            let flashes = 0;
            const maxFlashes = 4;
            const flashInterval = setInterval(() => {
                posts.forEach(p => {
                    p.material.emissive.setHex(flashes % 2 === 0 ? 0xFFFF00 : originalEmissive);
                });
                flashes++;
                if (flashes >= maxFlashes) {
                    clearInterval(flashInterval);
                }
            }, 150);
        }

        function createConfetti() {
            const confettiCount = 150;
            const confettiGeometry = new THREE.PlaneGeometry(0.1, 0.1);
            const colors = [0xffd700, 0xff69b4, 0x00bfff, 0x7cfc00, 0xff4500];

            for (let i = 0; i < confettiCount; i++) {
                const confettiMaterial = new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)], side: THREE.DoubleSide });
                const confetti = new THREE.Mesh(confettiGeometry, confettiMaterial);
                
                confetti.position.set(
                    THREE.MathUtils.randFloatSpread(15),
                    THREE.MathUtils.randFloat(10, 15),
                    THREE.MathUtils.randFloatSpread(5)
                );

                const particle = {
                    mesh: confetti,
                    velocity: new THREE.Vector3(
                        THREE.MathUtils.randFloatSpread(0.02),
                        -0.05 - Math.random() * 0.05,
                        THREE.MathUtils.randFloatSpread(0.02)
                    ),
                    rotationSpeed: new THREE.Vector3(
                        Math.random() * 0.1,
                        Math.random() * 0.1,
                        Math.random() * 0.1
                    )
                };
                confettiParticles.push(particle);
                confettiGroup.add(confetti);
            }
        }


        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const time = performance.now() * 0.005;

            // Animate flags
            flags.forEach(flag => {
                const positions = flag.geometry.attributes.position;
                const originalVertices = flag.userData.originalVertices;
                for (let i = 0; i < positions.count; i++) {
                    const originalX = originalVertices[i * 3];
                    const wave = Math.sin(originalX * 2 + time) * 0.15;
                    positions.setZ(i, wave);
                }
                positions.needsUpdate = true;
            });


            for (let i = confettiParticles.length - 1; i >= 0; i--) {
                const particle = confettiParticles[i];
                particle.mesh.position.add(particle.velocity);
                particle.mesh.rotation.x += particle.rotationSpeed.x;
                particle.mesh.rotation.y += particle.rotationSpeed.y;
                particle.mesh.rotation.z += particle.rotationSpeed.z;

                if (particle.mesh.position.y < -2) {
                    confettiGroup.remove(particle.mesh);
                    confettiParticles.splice(i, 1);
                }
            }

            if (isKeeperReacting && !keeperSaved && !goalScored) {
                keeperGroup.position.lerp(keeperTarget, 0.08);
                const ballSphere = new THREE.Sphere(ball.position, ballRadius);
                auraBoundingBox.setFromObject(collisionAura);
                if (auraBoundingBox.intersectsSphere(ballSphere)) {
                    if (shotTypeGlobal !== 'goal') {
                         handleCollision();
                    }
                }
            }
            
            if (isBallShot) {
                if (!goalScored && !keeperSaved) {
                    if (ball.position.z <= ballRadius && ball.position.z >= -ballRadius) {
                        if (Math.abs(ball.position.x - leftPost.position.x) < postRadius + ballRadius ||
                            Math.abs(ball.position.x - rightPost.position.x) < postRadius + ballRadius) {
                            if (ball.position.y < goalHeight) {
                                ballVelocity.x *= -0.8;
                            }
                        }
                        if (Math.abs(ball.position.y - crossbar.position.y) < postRadius + ballRadius) {
                            if (Math.abs(ball.position.x) < goalWidth / 2) {
                                ballVelocity.y *= -0.8;
                            }
                        }
                    }

                    if (ball.position.z <= 0 + ballRadius && Math.abs(ball.position.x) < goalWidth / 2 && ball.position.y < goalHeight) {
                        goalScored = true;
                    }
                }
                
                if (goalScored && !hasHitNet) {
                    if (ball.position.z <= -netDepth + ballRadius) {
                        hasHitNet = true;
                        netSound.triggerAttackRelease("8n");
                        ballVelocity.multiplyScalar(1.0 - 0.88);
                        ballVelocity.z *= -1;
                    }
                    if (Math.abs(ball.position.x) >= goalWidth / 2 - ballRadius) {
                         ballVelocity.x *= -0.8;
                    }
                     if (ball.position.y >= goalHeight - ballRadius) {
                         ballVelocity.y *= -0.8;
                    }
                }

                const horizontalVelocity = new THREE.Vector3(ballVelocity.x, 0, ballVelocity.z);
                const speed = horizontalVelocity.length();
                if (speed > 0.001) {
                    const distance = speed;
                    const rotationAngle = distance / ballRadius;
                    const rotationAxis = new THREE.Vector3().crossVectors(horizontalVelocity, new THREE.Vector3(0, 1, 0)).normalize();
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromAxisAngle(rotationAxis, rotationAngle);
                    ball.quaternion.premultiply(quaternion);
                }

                ballVelocity.add(gravity);
                ball.position.add(ballVelocity);

                if (ball.position.y < ballRadius) {
                    ball.position.y = ballRadius;
                    ballVelocity.y *= -0.4; 
                    ballVelocity.x *= 0.96; 
                    ballVelocity.z *= 0.96;
                }
            }

            const outOfBounds = ball.position.z < -netDepth - 2 || ball.position.z > 15 || Math.abs(ball.position.x) > 15;
            const goalRollStopped = goalScored && ball.position.y <= ballRadius && ballVelocity.length() < 0.02;
            if (isBallShot && !isResetting && (outOfBounds || (keeperSaved && ball.position.z > 10) || goalRollStopped)) {
                isResetting = true;
                resetTimeoutId = setTimeout(() => {
                    resetGame(false);
                }, 3000);
            }

            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        init();
    </script>
    
<script>
// --- START OF CONNECTION & LEADERBOARD ENGINE ---
(function() {
    // --- CONFIGURATION (عدّل هذه الإعدادات لكل لعبة) ---
    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzrf1-At3Pq7i39bGV3F1iD3-b0G-WWyRi5cgpKeQjyn_N5fh2EmGhoyRKUsbLd-F_UJQ/exec";
    const GAME_ID = 'g1_5_1';         // مثال: 'g1_1_1'
    const GAME_MAX_POINTS = 10;                     // أقصى نقاط في اللعبة
    const PLATFORM_MAX_GRADE = 5;                   // الدرجة النهائية في المنصة
    const METRIC_TYPE = 'time';                     // نوع المعيار: 'time', 'stars', 'errors'
    const METRIC_LABEL = 'الوقت (ثواني)';           // اسم المعيار للعرض في الجدول

    // --- Read URL Parameters ---
    const urlParams = new URLSearchParams(window.location.search);
    const studentId = urlParams.get('studentId');
    const classId = urlParams.get('classId');
    const studentName = urlParams.get('studentName');

    let currentUser = (studentId && studentName) ? { id: studentId, name: studentName } : null;

    // --- CORE FUNCTIONS ---

    // 1. الدالة الرئيسية التي تستدعيها عند انتهاء اللعبة
    window.saveAndFinishGame = function(points, metricValue) {
        const finalPoints = parseFloat(points) || 0;
        const finalMetric = parseFloat(metricValue) || 0;
        const maxPoints = parseFloat(GAME_MAX_POINTS) || 1;
        const finalGrade = (finalPoints / maxPoints) * PLATFORM_MAX_GRADE;

        const resultDisplay = document.getElementById('final-result-display');
        if (resultDisplay) {
            resultDisplay.innerHTML = `
                <p style="color: #374151;">النقاط: <span style="font-weight: bold; font-size: 1.25rem;">${finalPoints} / ${maxPoints}</span></p>
                <p style="color: #2563eb;">الدرجة في المنصة: <span style="font-weight: bold; font-size: 1.5rem;">${finalGrade.toFixed(1)} / ${PLATFORM_MAX_GRADE}</span></p>
            `;
        }

        if (studentId && classId) {
            const params = new URLSearchParams({
                action: 'saveGrade',
                studentId: studentId,
                classId: classId,
                itemId: GAME_ID,
                grade: finalGrade.toFixed(2),
                metricValue: Math.round(finalMetric).toString()
            });
            fetch(`${SCRIPT_URL}?${params.toString()}`)
                .then(res => res.json())
                .then(result => console.log('Save result:', result.status))
                .catch(err => console.error("Save Error:", err))
                .finally(fetchAndShowLeaderboard);
        } else {
            console.log(`Visitor finished. Score: ${finalPoints}, Metric: ${finalMetric}`);
            fetchAndShowLeaderboard();
        }
    }

    // 2. دالة جلب وعرض سجل الأبطال
    function fetchAndShowLeaderboard() {
        const loader = document.getElementById('leaderboard-loader');
        const container = document.getElementById('leaderboard-container');
        if (!loader || !container) return;
        
        if (!classId) {
            console.log("No classId found, skipping leaderboard for visitor.");
            container.innerHTML = `<p class="text-center text-gray-500 mt-4">سجل الأبطال متاح للطلاب المسجلين فقط.</p>`;
            showFinishButton();
            return;
        }

        loader.style.display = 'block';
        container.innerHTML = '';

        const params = new URLSearchParams({
            action: 'getLeaderboard',
            gameId: GAME_ID,
            metricType: METRIC_TYPE,
            classId: classId
        });

        fetch(`${SCRIPT_URL}?${params.toString()}`)
            .then(res => res.json())
            .then(response => {
                if (response.status === 'success' && response.data) {
                    displayLeaderboard(response.data);
                } else {
                    throw new Error(response.message || 'Failed to load leaderboard data.');
                }
            })
            .catch(err => {
                console.error("Leaderboard Error:", err);
                container.innerHTML = `<p class="text-center text-red-500">حدث خطأ في تحميل سجل الأبطال.</p>`;
            })
            .finally(() => {
                loader.style.display = 'none';
                showFinishButton();
            });
    }
    
    // 3. دالة بناء جدول سجل الأبطال
    function displayLeaderboard(data) {
        const container = document.getElementById('leaderboard-container');
        if (!data || data.length === 0) {
            container.innerHTML = `<p class="text-center text-gray-500 mt-4">لا توجد نتائج بعد. كن أول الأبطال!</p>`;
            return;
        }
        let tableHTML = `
            <div class="mt-6 border-t pt-4">
                <h3 class="text-2xl font-bold text-center text-gray-800 mb-4">🏆 سجل الأبطال 🏆</h3>
                <table class="min-w-full bg-white shadow-md rounded-lg">
                    <thead class="bg-gray-800 text-white">
                        <tr>
                            <th class="text-center py-2 px-3">الترتيب</th>
                            <th class="text-right py-2 px-3">اسم الطالب</th>
                            <th class="text-center py-2 px-3">الدرجة</th>
                            <th class="text-center py-2 px-3">${METRIC_LABEL}</th>
                        </tr>
                    </thead>
                    <tbody class="text-gray-700">`;
        data.forEach((player, index) => {
            const rank = index + 1;
            let rankDisplay = rank;
            if (rank === 1) rankDisplay = '🥇';
            if (rank === 2) rankDisplay = '🥈';
            if (rank === 3) rankDisplay = '🥉';
            const isCurrentUser = (currentUser && player.name === currentUser.name);
            const rowClass = isCurrentUser ? 'bg-blue-100 font-bold' : (index % 2 === 0 ? 'bg-gray-100' : '');
            tableHTML += `
                <tr class="${rowClass}">
                    <td class="text-center py-2 px-3 text-xl">${rankDisplay}</td>
                    <td class="text-right py-2 px-3">${player.name}</td>
                    <td class="text-center py-2 px-3">${player.grade.toFixed(1)}</td>
                    <td class="text-center py-2 px-3">${player.metricValue}</td>
                </tr>`;
        });
        tableHTML += `</tbody></table></div>`;
        container.innerHTML = tableHTML;
    }

    // 4. إظهار زر الإنهاء
    function showFinishButton() {
        const finishWrapper = document.getElementById('finish-game-wrapper');
        if (finishWrapper) {
            finishWrapper.style.display = 'block';
        }
    }

    // 5. التعامل مع زر الإنهاء وتخصيص رسالة الترحيب
    document.addEventListener('DOMContentLoaded', () => {
        // Personalize welcome message
        const welcomeMessage = document.getElementById('welcomeMessage');
        if (studentName && welcomeMessage) {
            welcomeMessage.innerHTML = `أهلاً بك يا <span style="font-weight: bold; color: #FFD700;">${studentName}</span>! استعد لتسديد ركلات الجزاء الحاسمة. كل إجابة صحيحة هي تسديدة نحو الهدف!`;
        }
        const finishBtn = document.getElementById('finish-game-btn');
        if (finishBtn) {
            finishBtn.addEventListener('click', () => {
                window.parent.postMessage({ event: 'gameFinished', gameId: GAME_ID }, '*');
            });
        }
    });
})();
// --- END OF CONNECTION & LEADERBOARD ENGINE ---
</script>
</body>
</html>
